# [一次程序优化经历，运行8小时到3小时到50分钟 - 知乎](https://zhuanlan.zhihu.com/p/69739946)

上周我遇到一个需要处理大文件的场景，需要遍历大文件，并且对数据进行一定的处理。由于这批数据对时效性要求较高，所以当时我编写的程序是希望运行地越快越好，所以我在编程的过程中对程序进行一次一次的优化，**最终从开始时需要运行8小时到现在只需运行50分钟，算是达到了需求**。

当然，你可能会说一开始的程序写得太烂，所以导致运行太紧，无所谓啦，这并不是重点。实际上，很多人第一次写程序都很难按预想那样写出简单高效的代码片段，只是有的场景对性能要求并不高，所以有的人看着自己的程序能运行后就不再进行优化了。其实，绝大多数程序都是有优化空间的，并且还有很大的优化空间，这个空间指的是时间和空间。

废话不多说，我把这次优化的过程和思路总结为8个点，分享出来，希望能对大家有所帮助。

## 1.需求

大数据时代，处理大量数据成为了不少程序员的家常便饭。那么多大的数据可以称为大数据呢？对于数据量，很难用一个确定的量去描述其界限，**我理解大数据不仅仅是数据量大，还应该具有数据复杂的特性，比如维度高、字段多。**

我平时处理的数据并不是大到磁盘都存不下那种，最多就是亿的量级。此次处理的数据是一个文本的大文件，数据量不到一亿，占用磁盘空间几百GB，它是行列结构，即每一行数据用tab键分割，有不到100个字段，其中有部分字段是json，且这个json异常复杂，一条大的数据可能会占用好几MB的空间。

**我要做的事情很简单，最费劲的就是在每一条数据的大json串中增加一个字段，这个字段经过了一些复杂的计算。**简单来说就是写程序遍历一遍这个文件，然后对每条数据做一些计算，其中包含了把一个字段塞到大json串中。

## **_2._Python**

**说到处理数据，我个人觉得Python是最好用的，当然它最caodan的地方是对中文编码不够支持，不过这还算是一个可以克服的缺点。**  

和往常一样，我用Python编写了一版，试着跑了一下数据，大约每一万条数据需要大约耗费5秒。算下来，大概需要跑8到10小时，这是不能接受的，所以我开始了一系列的优化。

另外多说一点，我们在测试自己的程序的时候，并不用全量的数据去测，比如从正式数据中去head(Linux命令，可以取文件头部的n行数据)出200万条数据来进行测试，跑完测试用例就可以大致估算出整个程序耗时了。

## **_3._并发**

因为程序中包含了一定的计算逻辑，即消耗CPU的逻辑片段(**说个题外话，有的程序可能是计算型的，比较耗CPU，有的是内存型的，比较耗内存，还有些是IO型的，大多数情况下磁盘读写会成为瓶颈**)，可能是受之前惯性思维的影响，对于优化的方法，我首先想到的就是增加程序的并发，开多个线程，开多个进程。多线程最简单，一是好实现，二是代码相对好控制。

三下两下把代码改成了多线程，这里我使用的是线程池而不是每来一条数据新创建一个线程去处理它，这样可以减少程序的运行时间。**所谓线程池就是，事先，一般在程序启动的时候先创建一定数量的线程，然后每次有处理需求时，就从线程池中捞一个线程来处理它，因为线程的创建和消亡是会消耗资源和时间的，所以，理论上，使用线程池就可以减少这部分创建和消亡的时间。**

我一开始创建了8个线程，运行了一下，程序并没有快多少，所以我又把线程数提到了16，最后提到了128，运行速度反而减慢了。还是因为惯性思维，因为Python的线程模型是N:1模型。**所谓N:1模型就是所有线程都跑在了一个物理核上，不同线程实际上是在同一个核上频繁切换。我认为多线程已经把一个核给榨干了，要提升程序的运行速度只能采取多进程。如果在CPU相对空闲时，不同的进程几乎是可以独占不同的物理核的，准确来说就是切换不太频繁，可以实现真正意义上的并发。**

说到多进程，对于处理大文件，程序运行最快的方法是将一个大文件按行平均切割成m份，然后开启m个进程独立地跑这些数据。不过按照之前的经验，使用Linux下的文件切割命令split来切割这么一个大文件，大概需要3个小时，这属于程序员的额外时间消耗，所以我放弃了。

我还是选择了进程池，在程序启动的时候主进程fork出许多子进程，即master/worker模式，并且自己实现了一个生产者消费者，否则任务等待队列会被撑爆的。

代码写好了以后，根据我的以往实验，在开启5个进程的时候程序运行得最快，并且总的运行时间是之前的80%左右。**优化效果并不好，因为进程池也会存在进程的切换，和真正独立的进程是有区别的。这几个进程不是一直在running状态，也是会经历进程的状态切换，running、wait、ready等状态。**

从8个小时缩短为6个多小时是远远不达标的，至少要在两个小时内才能接受。

## **_4._瓶颈**

瞎搞了这么久，我终于想着去理性地寻找瓶颈，一种最好的方式就是在程序运行的时候实时监控计算机的状态，比如大家熟知的命令top，第三方工具htop。我这里使用的是公司内部的监控工具，可以查看内存、CPU、IO的实时状态。

还有另一种方式就是计算程序每个部分的耗时，**如果你的程序封装或者抽象得足够好，我们是很容易计算某个代码片段的耗时的**，比如计算在程序流程中某个函数需要运行多长时间，我们只用在调用函数之前打印一下Unix时间戳，然后在函数运行结束的时候打印时间戳，最后做个差就能算出耗时了。所以说我们的程序要高内聚、低耦合，这样后期维护起来是很爽的。

经查看，我发现，在单线程的情况下，每处理一万条数据大致耗时5秒，其中计算只花费了不到一秒，中文编码解码耗时不到一秒，IO耗时差不多两秒，其中最耗时的就是解大json(json的decode和encode的步骤)，耗时两秒多一点。

通过监控计算机状态，在程序运行的时候我读写的那块磁盘的IO被打满了，原因是服务器上还有很多其他进程在读写这块磁盘。

所以这里有两个优化点，第一点就是优化IO，第二点就是把大json解包封包的时间缩短。

## **_5._磁盘**

说到IO，很多同学第一时间想到的就是换块SSD。换块SSD当然是个很好的解决办法，但是如果每次编写程序遇到IO问题都要通过硬件来优化，公司岂不是得破产？**程序员写代码并不是想要啥就有啥的，要用最小的预算达到目的。**

我所使用的服务器上并没有挂载SSD磁盘，倒是挂载了很多机械盘，并且很多盘都没有读写操作。在大多数情况下，我们所说的IO基本上都指的是某一块磁盘的IO。这里有一个优化点就是，我把读写的磁盘分离开，还是从之前的那块磁盘读数据，但是往另外一块磁盘写数据。

还是原来的单线程代码，什么也没有改变，程序的运行时间一下降低了四分之一。从8小时缩短为6小时。

## **_6._算法**

IO进行了一定的优化，接下来就该优化最耗时的json解包封包了。我使用的是Python的官方工具，json.loads和json.dumps。事实上，有时候官方的工具并不一定是最好的，就拿json处理的相关工具来说，同一种语言可能有很多不同的工具，它们的处理效率可能会相差10倍以上。

接下来的操作是不是该换个json解包封包工具了？我并不想这么做，因为有更快的方式，不知道大家还记得我前文提到的一句话吗？我是想在json串中增加一个字段，在多数情况下，增加比减少容易得多。既然是增加，那完全没有必要解包，正常情况下，我们从文件中读取的json串实际上是一个字符串，解包会把它变为一个dict，处理完，又把这个dict转化为一个字符串，然后再写入文件。**实际上，我们可以省略string转dict再从dict转string的步骤，因为json字符串的末尾是一个}符号，那么我们直接在}插入想要添加的字段即可。**

举个例子：加入原始的json字符串是：{"key1":"value1"} ,我们想要加上一个字段key2，那么可以直接对字符串做切片操作(切片是Python中的一个操作)。即可以直接把这个过程变成 {"key1":"value1" + "key2":"value2" + }。

**这么一做，程序运行从之前的6小时缩短为3小时，处理时间减少了一倍，这算是在算法上的提升。**

## **_7._语言**

3小时虽然已经比最开始的8小时快很多了，但我还是嫌弃它太长。Python虽然比较适合处理数据，写起来也比较容易，不过比较偏上层，无法进行更底层的控制，比如内存、线程、进程等。

都说Go语言的运行效率接近C++，开发效率接近Python，所以我也准备尝尝鲜。Go语言是编译型语言，并且其语言本身就支持进程线程等特性。当然，这里我并没使用并发，我只是用Go把之前的Python代码重新写了一遍，不过还是做了适当的优化。

> _1\. **为了让IO充分使用，我将Python一行一行的读写改为了Go语言一块一块的读写**，即之前是一次读一行，现在是一次读一块固定大小的二进制，然后用换行符来区分这一块里面的每一行，谁快谁慢一下就能见分晓。_  
> _2\. **我给文件的读写各添加了一个30MB的缓存，构成两个生产者消费者。**对写操作来说，生产者是代码处理逻辑，消费者是IO写。经测试，生产者的速度是快于消费者的(所以这里提高并发已经没有什么意义了，瓶颈在IO)。_

在这种情况下，最后整个程序运行完成只需要50分钟，已经在两个小时内了，符合了最初的需求。

## **_8._Todo**

其实这个程序还有优化的空间，因为已经符合我最开始的需求，我就没有继续再优化下去。我刚说到，程序的瓶颈在于IO写。那么我们可以同时往挂载在同一台机器上的多个磁盘循环写，这样就能分散每块磁盘的IO了。

**不过，写程序不能为了优化而优化，在开发效率和运行效率上我们要选择一个折中点。再盲目继续优化，代码的复杂度就该上升了。**

___

更多原创见我的个人微信公众号：**逆袭的二胖**

**精彩文章：**

![](https://pic3.zhimg.com/v2-6f86c79a6ad522c724ee57f738c5943a_b.jpg)
