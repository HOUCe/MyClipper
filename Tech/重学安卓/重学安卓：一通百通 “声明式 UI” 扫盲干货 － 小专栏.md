---
created: 2021-10-13
source: https://xiaozhuanlan.com/topic/2356748910
author: 
---

# [重学安卓：一通百通 “声明式 UI” 扫盲干货 － 小专栏](https://xiaozhuanlan.com/topic/2356748910)


> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

·

> **重要提示**：
> 
> 阅读本文的最佳时机是，**您已吃过** 阅读 “源码” 或 “源码分析文” 时 **找不到头绪的苦**。
> 
> 您没吃过苦，您先不要着急阅读本文。
> 
> 在您吃够这方面的苦后，您才有机会发现，本文正是专用于解决 “如何找到正确打开方式” 的困扰。
> 
> 我们绝不通篇贴源码，而是基于广泛的实践和反思，在累积过大量样本 乃至足以排除掉所有干扰信息后，**点到为止地揭露 声明式 UI 框架最为核心的本质**，方便您理解其真实的存在意义，乃至可以笃信地将其用在项目中。

## 前言

> Canvas 总共生了两胎，一胎是 View 体系，二胎是 Compose 体系，

上一期[《过目难忘 Android GUI 关系梳理》](https://xiaozhuanlan.com/topic/2073915486)，我们用 “通俗易懂” 的方式解析了 “View 体系” 每个层级工具的 **存在意义 及 相互间关系**，鉴于 Compose 离 “普及” 还有很长一段距离，这一期我们先来介绍 Compose 框架背后的本质。

## 声明式 UI 的由来

事实上，React、Flutter、SwiftUI、Jetpack Compose，这些 UI 框架有个共同鼻祖，即一个名为 elm（不是 “饿了么”）的 UI 框架，是它最早确立并推行了 “声明式 UI” 设计理念。

> 注：“声明式 UI” 这个名称，最初是谁定义的，暂时没有找到来源，目前各大官网都是称其为 “声明式 UI”，基于我个人理解，其更精确的表达是，“数据驱动 UI 框架下的声明式 UI 分支”，当然，最终我们还是简称为 “声明式 UI”。

—— 那么 “声明式 UI” 到底长啥样？为什么要使用 “声明式 UI”？它相比传统 “View” 有何优势？它的本质或者说存在意义又是什么？

—— React、Flutter、SwiftUI、Jetpack Compose，表面上每个都长得不一样，如何透过表象看穿它们的 “流程和机制”，从而能自行领悟代码 该怎么写、往哪写、怎么改？

所以今天我们就来统一解析 “声明式 UI” 背后的本质，相信阅读后能让你醍醐灌顶。

## 文章目录一览

-   前言
-   声明式 UI 的由来
-   **声明式 UI 的本质是 “函数式编程”**
    -   “纯函数” 是 “函数式编程” 的基石
    -   “函数式编程” 引入前的混沌世界
    -   **“函数式编程” 为什么能 “彻底” 解决这类问题？**
    -   引入 “函数式编程” 后的世界
-   所以为什么会有 “数据驱动 UI 框架”？
    -   **声明式 UI 的运作流程是怎样的？**
    -   **数据驱动 难以替代的好处**
-   函数式编程的局限
-   **Note 2020.07.27 加餐：**
-   现有条件下解决 “视图调用一致性问题” 的最优解
    -   1.Java + DataBinding 严格模式
    -   2.Kotlin + ViewBinding
    -   3.Kotlin DSL 动态布局
-   **Note 2020.07.31 加餐：**
    -   通过 “函数式编程思想” 秒懂 Compose 流程机制
-   综上

## 声明式 UI 的本质是 “函数式编程”

声明式 UI、Java8 Stream、RxJava 等，本质上都是函数式编程。

许多文章，从 RxJava 时代起，就照搬了官网的说法，说 RxJava 是一种 “响应式编程” 框架。

事实上，“响应式编程” 是一种 额外发明的称谓，“响应式编程” 这个概念 不仅无助于我们 正确理解事实，反倒徒添困扰 —— 为什么要用响应式编程 —— **没有人真的能够 就这个脱离事实的概念 把事情给你交代清楚**。

所以，我们不妨回归它最真实的本质 —— 函数式编程，好从根源的根源找寻线索，从而有机会 知其所以然、而顿悟般地 知其然。

## “纯函数” 是 “函数式编程” 的基石

老规矩，先讲结论：

> 声明式 UI 是 “数据驱动 UI 框架” 的一个分支，**声明式 UI 的实现方式是函数式编程，且函数式编程的基石是纯函数**。
> 
> 函数式编程的存在，主要是为了 **从范式层面彻底解决 过程的一致性问题**。
> 
> 数据驱动 UI 框架 主要是为了解决 **视图调用的一致性问题**。

如果光是阅读了以上三点，你还是不理解的话，那接下来我就分别介绍 99% 的网文都不曾介绍的真实状况，来方便你迅速地建立起感性的认识。

## “函数式编程” 引入前的混沌世界

以下是我们最常见的用法：

通过 findViewById 拿到 TextView 实例，使其作为 Activity 内部的共享成员变量，为多个方法所调用，来改变 TextView 的状态。

![](https://images.xiaozhuanlan.com/photo/2021/1889f3a3310af0351ba8fe2d1ed83a97.png)

这造成了什么问题呢？

**一旦 TextView 成为共享变量，被分散到各个方法中，后续就不可控了**，因为当执行方法 B 时，方法 A 是无法知道 方法 B 中对共享变量做了什么，却无差别地承受 共享变量被修改 所带来的影响，

比如当 方法 B 将 TextView 置空，那么 方法 A 调用 TextView 实例时 将面临 null 安全问题。

> 可能有人会问，这种问题 通过手动判空 不就可以了？

事实上，**在软件工程的背景下，任何微小的隐患 都可能被 “指数级” 地放大**。

一个软件的页面可能有数十个，每个页面的控件也可能多达十数个，而每个控件都可能分散在多个方法中，这种情况下，一味地寄希望于手动判空，是成本极高 且存在 **一致性风险** 的 —— 总会有疏忽的时候，总会有 方法 A 记得判空，而方法 B 忘记的时候。

## “函数式编程” 为什么能 “彻底” 解决这类问题？

因为函数式编程基于纯函数。

**什么是纯函数？为什么纯函数最终能解决这个问题？**

简单来说，纯函数相比普通函数的特征是：

**只有一个入口 & 只有一个出口**。

啥意思呢，就是说：

> 函数只从 **参数列表** 这唯一入口 接收外来的初值，
> 
> 并且只从 **返回值** 这唯一出口 返回结果数据。

除此之外：

> 不在函数内部执行与运算本身无关的其他操作，
> 
> 不在函数内部调用外部变量、不修改从外部传进来的变量，

抛开上述 TextView 的案例，我们先来举个例子看看纯函数本身：

![](https://images.xiaozhuanlan.com/photo/2021/5bdf1436e1d8bc1f7a8957aa509d774a.png)

如此一来，在调用该函数时，**关注点就只有 入口和出口 这两处**，而不至于蔓延到整个程序，从而 不可预期情况发生的概率 从 99.9% 骤减为 0 —— **调用者无须了解细节 即可放心调用**。

## 引入 “函数式编程” 后的世界

函数式编程，除了单个纯函数，也可以是多个纯函数的链式编程，

即，**上一个函数的输出 作为下一个函数的输入**，

整个链同样只有 开头的入参 这一个入口，和 末尾的回调 这一个出口，

![](https://images.xiaozhuanlan.com/photo/2021/4c203f52aa7310aaea86b9782fb926f2.png)

至此，我们得以顿悟般地理解：为什么 RxJava 或 Java8 Stream 是这样书写、为什么会和常规的 “侵入式” 思维发生 “别扭” …

是的，正因为人们无意识地习惯了 “自由散漫” 的编程，而从未意识到还有 “集中管理” 的范式的存在，于是在遇到 RxJava 链式编程的第一感觉就是，“自由散漫” 在此行不通了，

而这也恰恰是 函数式编程 的存在意义：**从范式层面彻底解决 过程的一致性问题** —— **有怎样的输入，就有且只有怎样的输出**，关注点只有这两处，因集中管理 而从根本上杜绝了不可预期的结果。

> 划重点 👆 👆 👆

## 所以为什么会有 “数据驱动 UI 框架”？

> 将 “视图系统” 设计为 “数据驱动”，反映了源码设计者 对 **彻底解决软工安全问题** 的不懈追求。
> 
> 正是由于这锐意进取的 **"死磕精神"**，使得软件开发得以不断优化和改进。

通过 "混沌世界" 一节的分析，我们已确知，在 “自由散漫” 的环境下，**因实例的分散，而使不可预期的风险被大幅扩散**，

加上我们在 [《从被误解到 “真香” 的 Jetpack DataBinding》](https://xiaozhuanlan.com/topic/9816742350) 一文中提到的，"横竖屏布局的控件存在差异" 这一经典案例，如采用 "自由散漫" 的方式，同样会埋下视图调用 的一致性问题。

那怎么办呢？

## 声明式 UI 的运作流程是怎样的？

很简单 —— 使用 **基于函数式编程 的 数据驱动 UI 框架**

> Tip：非 DataBinding。DataBinding 是另一种方式 —— 通过 “**自动化生成中间代码**”，来规避人工调用视图实例造成的一致性隐患，但既然是额外的工具，便没能迫使 原视图系统 遵循函数式编程。

其存在意义主要就是为了解决 **视图调用的一致性问题**：

> **从唯一入口输入 “声明树”，在内部通过对比新旧声明的差异，自行完成 “视图实例树” 的构建或调整，并输出最终结果到屏幕**，使得开发者 没有机会 基于入侵式思维 直接对视图实例本身 进行调用和赋值，任何改变，只能从唯一入口注入 —— **用数据 来驱动整个过程的改变**。
> 
> 👆👆👆 划重点

![](https://images.xiaozhuanlan.com/photo/2021/c53657937acde54ca6ea0a762c2dd32e.gif)

所以，至此，无论是 React Native、Flutter 还是 SwiftUI、 Jetpack Compose，

它为什么要这样写、为什么是这样写、该怎么写，是不是都不言而喻了呢 ——

它的本质是数据驱动，只有唯一入口、通过数据来驱动，

因而 **视图逻辑，只能在 “用于返回给后台” 的声明树中编写、并且是结合 “输入的状态” 来指导逻辑的走向**，

> 👆👆👆 你品，你细品

并且至此，我们得以顿悟 为啥 “声明式 UI” 框架中，视图的隐藏不是直接 `mView.setVisible(false)`，因为本来就是基于函数式编程 —— **你接触不到作为函数内部成员的 视图实例**（Flutter 称 Element），**你能左右的只有在函数入口 作为入参的声明树**（Flutter 称 Widget）——

也即，在数据驱动的背景下，无论是想要内部视图实例发生隐藏，还是别的什么状态的变化，**每次都只能 “重来一遍”** —— **通过 setState 方法重新赋予状态值，并重走一次 render 方法来重建声明树**，最终后台会根据重建前后声明树的差异，来筛选出状态的变化逻辑，从而来决定内部真正视图实例的状态变化，如此来彻底规避上文提到的视图实例调用的 null 安全一致性问题。

> 👆👆👆 划重点

## 数据驱动 难以替代的好处

既然是基于函数式编程，那么便脱离了 "自由散漫" 时期的不可控，

那么除了上述提到的 null 安全问题，基于函数式编程方式实现的 “数据驱动” 的另一大不可替代的好处就是，**支持 "热重载"**，

相信不管 React Native、Flutter 还是 Jetpack Compose 和 SwiftUI，都会在各自的官网页面上吹嘘自家的这个 UI 框架支持热重载 —— 改改布局逻辑，点击预览按钮，可实时查看动态代码的效果。

> 要知道，旧时候，为了查看动态代码效果，哪怕只是改了一行代码、一个参数，也只能整个项目重新编译。在中大型项目中，Android Studio 全量编译一次少说 30s、还得烦着自己一次次地手动跳转和复现目标场景。而热重载的这一特性 对视图预览时间的节约十分可观。
> 
> (强迫症的我，经常为了一个坐标参数，抠像素地来来回回修改不下 10 数次，有了热重载，对一个页面元素的修改可节省约 500 秒，也即将近 10 分钟)

除此之外，数据驱动可能引发客户端开发的变革 —— 将来 UI 层的开发，可能可以完全外包给 Sketch 等设计软件，设计师在通过 Sketch 完成设计稿时，即可一键生成 React Native、Flutter 或是 Jetpack Compose 和 SwiftUI 等布局代码，客户端开发者的工作 可能被进一步地精简至数据层 甚至后端。

## “函数式编程” 的局限

当然，在谈论了这么多函数式编程好处的同时，也得提一提它的局限性。

毕竟，面世于 2015 年的 React Native 发展了这么多年，为啥没有被确立为视图开发的行业标准呢？

> 抛开底层架构的设计问题，其实更多的是来自 函数式编程本身的性能问题。

我们知道，函数式编程 主要是为了 在软件工程的背景下，解决过程的一致性问题，

并且很多时候，软件工程和算法性能，是相互冲突的，

通过函数式编程，我们彻底地解决了因 "自由散漫" 而存在的 null 安全隐患 和 结果的不可再现，但函数式编程 "只有一个入口" 和 **基于递归算法的 "链式调用"** ，完全是在拿性能来换软工安全。

> 由于只有一个入口，每次状态发生改变，都不得不重走一次入口、重新生成整个布局树，然后在内部生成真正的视图树，或根据前后布局树的差异调整视图树。
> 
> 要知道，旧版 Android 视图系统，为了将性能优化到极致，不顾代码的晦涩和丑陋 —— 比如在 MeasureSpec 中使用移位运算，而不是新建一个变量来存储测量模式；又如在事件分发过程中，通过 Flag 来存储和判断 "是否继续分发给子控件" 的信号，而不是每一次都重新运算一遍。

也即，函数式编程，客观来说，比较适合 "在子线程中运行的背景任务"，而不适合像 视图系统 这种，对实时响应的要求很高的密集型计算。(例如 60Hz 刷新率下，16ms 内就得完成一次完整的排版和渲染)

## Note 2020.07.27 加餐：

### 现有条件下解决 “视图调用一致性问题” 的最优解

#### 1.Java + DataBinding 严格模式

DataBinding 严格模式 是我基于对 “**数据驱动 UI 框架的本质即解决视图调用一致性问题**” 的独家理解，而在 2020.04.17 自创的 DataBinding 开发模式。

DataBinding 严格模式通过将 mBinding 实例限制在基类，避免开发者通过 mBinding 拿到 View 实例，从而 **彻底规避** 视图调用的一致性问题、让视图调用的 **安全系数** 与基于函数式编程思想的 Jetpack Compose 持平。

> 具体可以参考[《最佳实践》](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)项目的 DataBindingFragment 类。（目前已抽取到远程仓库，可在项目中通过双击 Shift 来搜索）

当然，这样也使传统的属性动画等操作无法编写。

好消息是，基于 ConstraintLayout 的 Motion 动画可以完美解决这一问题 —— **一行代码不用写，全在 xml 中搞定**。并且 Motion 动画将动画的制作难度和成本降低了 90%。具体可参考我们近期组织的 MotionChallenge 活动（提供一学就会的 Motion 动画教程）

[https://github.com/Jetpack-Missionary/MotionChallenge](https://github.com/Jetpack-Missionary/MotionChallenge)

#### 2.Kotlin + ViewBinding

Kotlin 下完全可以抛弃 DataBinding，直接使用 ViewBinding，这样可以规避 DataBinding 的所有问题，且在 Kotlin 本身语法糖及 IDE 规则的约束下，ViewBinding 同样可以完全避免 “视图实例 Null 安全的一致性问题”。

#### 3.Kotlin DSL 动态布局

即是通过 kotlin DSL 来代替从 xml 布局解析和实例化 View。

一方面可以提升视图初始化效率，另一方面可以在 kotlin `?` 操作符的加持下，规避不可预期的 null 安全问题。

掘金有一位作者已实现了这样动态布局的方式。

[https://juejin.im/post/5eb07c3c5188256d924367fb](https://juejin.im/post/5eb07c3c5188256d924367fb)

并且正如我在文末提到的：如果能基于同一套 DSL，来分别在 IDE 布局预览和编译时 “分治”，那么即可基于函数式编程的 “热重载” 特性在 IDE 中实现 “实时预览”，以及在编译时通过 “自动生成代码” 来规避 null 安全问题、以及实现高性能的交互体验。

## Note 2020.07.31 加餐：

#### 通过 “函数式编程思想” 秒懂 Compose 流程机制

不知道在 “所以为什么会有数据驱动 UI 框架” 一节，我这样说有没有把话说明白？

> 数据驱动 UI 框架目前有两种实现方式，一种是函数式编程思想的设计，另一种是自动化代码生成的设计，但无论哪一种，归根结底是为了解决视图调用的一致性问题。
> 
> 这些是属于 **软件工程** 背景下的问题，我和多位程序员出身的、8 年以上工龄的创业者聊过这些。其中一位和我不约而同地提到了 “一致性问题”，而另一位提到了 “指数规模效应”（也即我所谓的 “破窗效应”）。
> 
> 这两个其实反映的是同一件事。就 “视图调用” 这事来说，一旦视图实例暴露，null 安全一致性问题 和 不受控制的指数规模效应 都将接踵而至。

然后注意看， 上述一节配图中的 render 方法，最终返回的 Widget 实例或者说 “布局树模型”，是作为入参，来传入到后台的机制中 在其内部完成 “视图树” 的更新和渲染。

也即，**作为开发者，我们能接触的就是 作为入口的 render 方法，和作为出口的 反映在触摸屏上的 肉眼可见、可触控的视图**（用于触发下一次的输入），除此之外，中间过程全被封装在后台，外部无法从旁干预，外部只能通过在入口处的输入 来在出口处获得对应的结果。如此来避免了 因中间过程被干预 而造成的各种 视图调用一致性问题。

数据驱动 UI 框架就是基于这样一个目的来实现的。

![Jetpack Compose UI 声明示例](https://images.xiaozhuanlan.com/photo/2021/64362a6c6198e8ace9043d354def8753.png)

Jetpack Compose UI 声明示例

> Jetpack Compose 和 SwiftUI 由于 DSL 封装抽象的太过了，乃至连返回布局树给后台的 render 方法都看不见（如上图，没有返回值，只有 [@Composable](https://xiaozhuanlan.com/u/Composable) 等注解） —— 这也是为什么 小伙伴们 **务必提前铺垫好 “函数式编程思想” 这一前置知识，如此方有机会越过表象，从函数式编程思想的角度出发来理解** 诸如上文提到的 “视图隐藏” 的写法。
> 
> 👆👆👆 划重点
> 
> 注：“一致性” 是 “软件工程安全” 领域的概念，对 “一致性” 概念不理解的小伙伴可参考[《架构组件 “一致性” 概念 全面解析》](https://xiaozhuanlan.com/topic/9340256871)。

## 综上

声明式 UI 是 “数据驱动 UI 框架” 的一种，**声明式 UI 的本质是函数式编程，且函数式编程的基石是纯函数**。

函数式编程的存在，主要是为了 **从范式层面彻底解决 过程的一致性问题**。

也即，函数式编程的特征是：**只有一个入口、并且 只有一个出口**，在运算过程中 **不包含与目的无关的隐含操作，也无法对运算过程 从旁干预**，从而 **确保了运算过程的可控、避免不可预期的状况的发生**。

数据驱动 主要是为了解决 **视图调用 乃至 视图实例 Null 安全的一致性问题**。

数据驱动的一大不可替代的好处是，**支持热重载、使布局动态编码的实时预览成为可能**。

函数式编程为了追求极致的软件工程设计，而先天地性能薄弱，因而**适合用于子线程中运行的背景任务**（RxJava 或 Java8 Stream 等数据层操作），而 **不适合对实时性要求较高的密集型任务**。

因此，将来的 Jetpack Compose 若是能对 调试和打包 采取 "分而治之" 的编译方式，兼顾 **编码时的 软工安全 + 实时预览** 和 **运行时的高性能**，那么新视图系统的全面更替 将指日可待。

> **便捷链接：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)
> 
> **视图系列文章：**
> 
> [重学安卓：从 0 到 1 “自定义视图” 完整爬坑顺序](https://xiaozhuanlan.com/topic/9361075842)
> 
> [重学安卓：滑动冲突 的快乐你不懂！](https://xiaozhuanlan.com/topic/8796215034)
> 
> [重学安卓：不如我们 从零开始设计一套 视图系统](https://xiaozhuanlan.com/topic/0162375948)
> 
> [重学安卓：百闻不如一见的 视图系统 架构全貌](https://xiaozhuanlan.com/topic/6420935178)
> 
> **[重学安卓：过目难忘 Android GUI 关系梳理](https://xiaozhuanlan.com/topic/2073915486)**
> 
> [重学安卓：一通百通 “声明式 UI” 扫盲干货](https://xiaozhuanlan.com/topic/2356748910)

## 版权声明

> Copyright © 2019-present KunMinX

文中提到的 “声明式 UI 是数据驱动 UI 框架的一种”、“声明式 UI 的本质是函数式编程”、“函数式编程的存在是为了 **从范式层面彻底解决 过程的一致性问题**”、**对之所以能通过 “纯函数乃至函数式编程” 来 “彻底解决一致性问题” 的原因的解析**、“数据驱动 UI 框架的本质 是在软件工程背景下 解决视图调用一致性问题”、“**DataBinding 严格模式**”、“DSL 预览和编译时分治” 等多处 **对特定现象及其本质的概括，均属于本人独立原创的成果**，本人对此享有最终解释权。

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。

> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

·

> **重要提示**：
> 
> 阅读本文的最佳时机是，**您已吃过** 阅读 “源码” 或 “源码分析文” 时 **找不到头绪的苦**。
> 
> 您没吃过苦，您先不要着急阅读本文。
> 
> 在您吃够这方面的苦后，您才有机会发现，本文正是专用于解决 “如何找到正确打开方式” 的困扰。
> 
> 我们绝不通篇贴源码，而是基于广泛的实践和反思，在累积过大量样本 乃至足以排除掉所有干扰信息后，**点到为止地揭露 声明式 UI 框架最为核心的本质**，方便您理解其真实的存在意义，乃至可以笃信地将其用在项目中。

## 前言

> Canvas 总共生了两胎，一胎是 View 体系，二胎是 Compose 体系，

上一期[《过目难忘 Android GUI 关系梳理》](https://xiaozhuanlan.com/topic/2073915486)，我们用 “通俗易懂” 的方式解析了 “View 体系” 每个层级工具的 **存在意义 及 相互间关系**，鉴于 Compose 离 “普及” 还有很长一段距离，这一期我们先来介绍 Compose 框架背后的本质。

## 声明式 UI 的由来

事实上，React、Flutter、SwiftUI、Jetpack Compose，这些 UI 框架有个共同鼻祖，即一个名为 elm（不是 “饿了么”）的 UI 框架，是它最早确立并推行了 “声明式 UI” 设计理念。

> 注：“声明式 UI” 这个名称，最初是谁定义的，暂时没有找到来源，目前各大官网都是称其为 “声明式 UI”，基于我个人理解，其更精确的表达是，“数据驱动 UI 框架下的声明式 UI 分支”，当然，最终我们还是简称为 “声明式 UI”。

—— 那么 “声明式 UI” 到底长啥样？为什么要使用 “声明式 UI”？它相比传统 “View” 有何优势？它的本质或者说存在意义又是什么？

—— React、Flutter、SwiftUI、Jetpack Compose，表面上每个都长得不一样，如何透过表象看穿它们的 “流程和机制”，从而能自行领悟代码 该怎么写、往哪写、怎么改？

所以今天我们就来统一解析 “声明式 UI” 背后的本质，相信阅读后能让你醍醐灌顶。

## 文章目录一览

-   前言
-   声明式 UI 的由来
-   **声明式 UI 的本质是 “函数式编程”**
    -   “纯函数” 是 “函数式编程” 的基石
    -   “函数式编程” 引入前的混沌世界
    -   **“函数式编程” 为什么能 “彻底” 解决这类问题？**
    -   引入 “函数式编程” 后的世界
-   所以为什么会有 “数据驱动 UI 框架”？
    -   **声明式 UI 的运作流程是怎样的？**
    -   **数据驱动 难以替代的好处**
-   函数式编程的局限
-   **Note 2020.07.27 加餐：**
-   现有条件下解决 “视图调用一致性问题” 的最优解
    -   1.Java + DataBinding 严格模式
    -   2.Kotlin + ViewBinding
    -   3.Kotlin DSL 动态布局
-   **Note 2020.07.31 加餐：**
    -   通过 “函数式编程思想” 秒懂 Compose 流程机制
-   综上

## 声明式 UI 的本质是 “函数式编程”

声明式 UI、Java8 Stream、RxJava 等，本质上都是函数式编程。

许多文章，从 RxJava 时代起，就照搬了官网的说法，说 RxJava 是一种 “响应式编程” 框架。

事实上，“响应式编程” 是一种 额外发明的称谓，“响应式编程” 这个概念 不仅无助于我们 正确理解事实，反倒徒添困扰 —— 为什么要用响应式编程 —— **没有人真的能够 就这个脱离事实的概念 把事情给你交代清楚**。

所以，我们不妨回归它最真实的本质 —— 函数式编程，好从根源的根源找寻线索，从而有机会 知其所以然、而顿悟般地 知其然。

## “纯函数” 是 “函数式编程” 的基石

老规矩，先讲结论：

> 声明式 UI 是 “数据驱动 UI 框架” 的一个分支，**声明式 UI 的实现方式是函数式编程，且函数式编程的基石是纯函数**。
> 
> 函数式编程的存在，主要是为了 **从范式层面彻底解决 过程的一致性问题**。
> 
> 数据驱动 UI 框架 主要是为了解决 **视图调用的一致性问题**。

如果光是阅读了以上三点，你还是不理解的话，那接下来我就分别介绍 99% 的网文都不曾介绍的真实状况，来方便你迅速地建立起感性的认识。

## “函数式编程” 引入前的混沌世界

以下是我们最常见的用法：

通过 findViewById 拿到 TextView 实例，使其作为 Activity 内部的共享成员变量，为多个方法所调用，来改变 TextView 的状态。

![](https://images.xiaozhuanlan.com/photo/2021/1889f3a3310af0351ba8fe2d1ed83a97.png)

这造成了什么问题呢？

**一旦 TextView 成为共享变量，被分散到各个方法中，后续就不可控了**，因为当执行方法 B 时，方法 A 是无法知道 方法 B 中对共享变量做了什么，却无差别地承受 共享变量被修改 所带来的影响，

比如当 方法 B 将 TextView 置空，那么 方法 A 调用 TextView 实例时 将面临 null 安全问题。

> 可能有人会问，这种问题 通过手动判空 不就可以了？

事实上，**在软件工程的背景下，任何微小的隐患 都可能被 “指数级” 地放大**。

一个软件的页面可能有数十个，每个页面的控件也可能多达十数个，而每个控件都可能分散在多个方法中，这种情况下，一味地寄希望于手动判空，是成本极高 且存在 **一致性风险** 的 —— 总会有疏忽的时候，总会有 方法 A 记得判空，而方法 B 忘记的时候。

## “函数式编程” 为什么能 “彻底” 解决这类问题？

因为函数式编程基于纯函数。

**什么是纯函数？为什么纯函数最终能解决这个问题？**

简单来说，纯函数相比普通函数的特征是：

**只有一个入口 & 只有一个出口**。

啥意思呢，就是说：

> 函数只从 **参数列表** 这唯一入口 接收外来的初值，
> 
> 并且只从 **返回值** 这唯一出口 返回结果数据。

除此之外：

> 不在函数内部执行与运算本身无关的其他操作，
> 
> 不在函数内部调用外部变量、不修改从外部传进来的变量，

抛开上述 TextView 的案例，我们先来举个例子看看纯函数本身：

![](https://images.xiaozhuanlan.com/photo/2021/5bdf1436e1d8bc1f7a8957aa509d774a.png)

如此一来，在调用该函数时，**关注点就只有 入口和出口 这两处**，而不至于蔓延到整个程序，从而 不可预期情况发生的概率 从 99.9% 骤减为 0 —— **调用者无须了解细节 即可放心调用**。

## 引入 “函数式编程” 后的世界

函数式编程，除了单个纯函数，也可以是多个纯函数的链式编程，

即，**上一个函数的输出 作为下一个函数的输入**，

整个链同样只有 开头的入参 这一个入口，和 末尾的回调 这一个出口，

![](https://images.xiaozhuanlan.com/photo/2021/4c203f52aa7310aaea86b9782fb926f2.png)

至此，我们得以顿悟般地理解：为什么 RxJava 或 Java8 Stream 是这样书写、为什么会和常规的 “侵入式” 思维发生 “别扭” …

是的，正因为人们无意识地习惯了 “自由散漫” 的编程，而从未意识到还有 “集中管理” 的范式的存在，于是在遇到 RxJava 链式编程的第一感觉就是，“自由散漫” 在此行不通了，

而这也恰恰是 函数式编程 的存在意义：**从范式层面彻底解决 过程的一致性问题** —— **有怎样的输入，就有且只有怎样的输出**，关注点只有这两处，因集中管理 而从根本上杜绝了不可预期的结果。

> 划重点 👆 👆 👆

## 所以为什么会有 “数据驱动 UI 框架”？

> 将 “视图系统” 设计为 “数据驱动”，反映了源码设计者 对 **彻底解决软工安全问题** 的不懈追求。
> 
> 正是由于这锐意进取的 **"死磕精神"**，使得软件开发得以不断优化和改进。

通过 "混沌世界" 一节的分析，我们已确知，在 “自由散漫” 的环境下，**因实例的分散，而使不可预期的风险被大幅扩散**，

加上我们在 [《从被误解到 “真香” 的 Jetpack DataBinding》](https://xiaozhuanlan.com/topic/9816742350) 一文中提到的，"横竖屏布局的控件存在差异" 这一经典案例，如采用 "自由散漫" 的方式，同样会埋下视图调用 的一致性问题。

那怎么办呢？

## 声明式 UI 的运作流程是怎样的？

很简单 —— 使用 **基于函数式编程 的 数据驱动 UI 框架**

> Tip：非 DataBinding。DataBinding 是另一种方式 —— 通过 “**自动化生成中间代码**”，来规避人工调用视图实例造成的一致性隐患，但既然是额外的工具，便没能迫使 原视图系统 遵循函数式编程。

其存在意义主要就是为了解决 **视图调用的一致性问题**：

> **从唯一入口输入 “声明树”，在内部通过对比新旧声明的差异，自行完成 “视图实例树” 的构建或调整，并输出最终结果到屏幕**，使得开发者 没有机会 基于入侵式思维 直接对视图实例本身 进行调用和赋值，任何改变，只能从唯一入口注入 —— **用数据 来驱动整个过程的改变**。
> 
> 👆👆👆 划重点

![](https://images.xiaozhuanlan.com/photo/2021/c53657937acde54ca6ea0a762c2dd32e.gif)

所以，至此，无论是 React Native、Flutter 还是 SwiftUI、 Jetpack Compose，

它为什么要这样写、为什么是这样写、该怎么写，是不是都不言而喻了呢 ——

它的本质是数据驱动，只有唯一入口、通过数据来驱动，

因而 **视图逻辑，只能在 “用于返回给后台” 的声明树中编写、并且是结合 “输入的状态” 来指导逻辑的走向**，

> 👆👆👆 你品，你细品

并且至此，我们得以顿悟 为啥 “声明式 UI” 框架中，视图的隐藏不是直接 `mView.setVisible(false)`，因为本来就是基于函数式编程 —— **你接触不到作为函数内部成员的 视图实例**（Flutter 称 Element），**你能左右的只有在函数入口 作为入参的声明树**（Flutter 称 Widget）——

也即，在数据驱动的背景下，无论是想要内部视图实例发生隐藏，还是别的什么状态的变化，**每次都只能 “重来一遍”** —— **通过 setState 方法重新赋予状态值，并重走一次 render 方法来重建声明树**，最终后台会根据重建前后声明树的差异，来筛选出状态的变化逻辑，从而来决定内部真正视图实例的状态变化，如此来彻底规避上文提到的视图实例调用的 null 安全一致性问题。

> 👆👆👆 划重点

## 数据驱动 难以替代的好处

既然是基于函数式编程，那么便脱离了 "自由散漫" 时期的不可控，

那么除了上述提到的 null 安全问题，基于函数式编程方式实现的 “数据驱动” 的另一大不可替代的好处就是，**支持 "热重载"**，

相信不管 React Native、Flutter 还是 Jetpack Compose 和 SwiftUI，都会在各自的官网页面上吹嘘自家的这个 UI 框架支持热重载 —— 改改布局逻辑，点击预览按钮，可实时查看动态代码的效果。

> 要知道，旧时候，为了查看动态代码效果，哪怕只是改了一行代码、一个参数，也只能整个项目重新编译。在中大型项目中，Android Studio 全量编译一次少说 30s、还得烦着自己一次次地手动跳转和复现目标场景。而热重载的这一特性 对视图预览时间的节约十分可观。
> 
> (强迫症的我，经常为了一个坐标参数，抠像素地来来回回修改不下 10 数次，有了热重载，对一个页面元素的修改可节省约 500 秒，也即将近 10 分钟)

除此之外，数据驱动可能引发客户端开发的变革 —— 将来 UI 层的开发，可能可以完全外包给 Sketch 等设计软件，设计师在通过 Sketch 完成设计稿时，即可一键生成 React Native、Flutter 或是 Jetpack Compose 和 SwiftUI 等布局代码，客户端开发者的工作 可能被进一步地精简至数据层 甚至后端。

## “函数式编程” 的局限

当然，在谈论了这么多函数式编程好处的同时，也得提一提它的局限性。

毕竟，面世于 2015 年的 React Native 发展了这么多年，为啥没有被确立为视图开发的行业标准呢？

> 抛开底层架构的设计问题，其实更多的是来自 函数式编程本身的性能问题。

我们知道，函数式编程 主要是为了 在软件工程的背景下，解决过程的一致性问题，

并且很多时候，软件工程和算法性能，是相互冲突的，

通过函数式编程，我们彻底地解决了因 "自由散漫" 而存在的 null 安全隐患 和 结果的不可再现，但函数式编程 "只有一个入口" 和 **基于递归算法的 "链式调用"** ，完全是在拿性能来换软工安全。

> 由于只有一个入口，每次状态发生改变，都不得不重走一次入口、重新生成整个布局树，然后在内部生成真正的视图树，或根据前后布局树的差异调整视图树。
> 
> 要知道，旧版 Android 视图系统，为了将性能优化到极致，不顾代码的晦涩和丑陋 —— 比如在 MeasureSpec 中使用移位运算，而不是新建一个变量来存储测量模式；又如在事件分发过程中，通过 Flag 来存储和判断 "是否继续分发给子控件" 的信号，而不是每一次都重新运算一遍。

也即，函数式编程，客观来说，比较适合 "在子线程中运行的背景任务"，而不适合像 视图系统 这种，对实时响应的要求很高的密集型计算。(例如 60Hz 刷新率下，16ms 内就得完成一次完整的排版和渲染)

## Note 2020.07.27 加餐：

### 现有条件下解决 “视图调用一致性问题” 的最优解

#### 1.Java + DataBinding 严格模式

DataBinding 严格模式 是我基于对 “**数据驱动 UI 框架的本质即解决视图调用一致性问题**” 的独家理解，而在 2020.04.17 自创的 DataBinding 开发模式。

DataBinding 严格模式通过将 mBinding 实例限制在基类，避免开发者通过 mBinding 拿到 View 实例，从而 **彻底规避** 视图调用的一致性问题、让视图调用的 **安全系数** 与基于函数式编程思想的 Jetpack Compose 持平。

> 具体可以参考[《最佳实践》](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)项目的 DataBindingFragment 类。（目前已抽取到远程仓库，可在项目中通过双击 Shift 来搜索）

当然，这样也使传统的属性动画等操作无法编写。

好消息是，基于 ConstraintLayout 的 Motion 动画可以完美解决这一问题 —— **一行代码不用写，全在 xml 中搞定**。并且 Motion 动画将动画的制作难度和成本降低了 90%。具体可参考我们近期组织的 MotionChallenge 活动（提供一学就会的 Motion 动画教程）

[https://github.com/Jetpack-Missionary/MotionChallenge](https://github.com/Jetpack-Missionary/MotionChallenge)

#### 2.Kotlin + ViewBinding

Kotlin 下完全可以抛弃 DataBinding，直接使用 ViewBinding，这样可以规避 DataBinding 的所有问题，且在 Kotlin 本身语法糖及 IDE 规则的约束下，ViewBinding 同样可以完全避免 “视图实例 Null 安全的一致性问题”。

#### 3.Kotlin DSL 动态布局

即是通过 kotlin DSL 来代替从 xml 布局解析和实例化 View。

一方面可以提升视图初始化效率，另一方面可以在 kotlin `?` 操作符的加持下，规避不可预期的 null 安全问题。

掘金有一位作者已实现了这样动态布局的方式。

[https://juejin.im/post/5eb07c3c5188256d924367fb](https://juejin.im/post/5eb07c3c5188256d924367fb)

并且正如我在文末提到的：如果能基于同一套 DSL，来分别在 IDE 布局预览和编译时 “分治”，那么即可基于函数式编程的 “热重载” 特性在 IDE 中实现 “实时预览”，以及在编译时通过 “自动生成代码” 来规避 null 安全问题、以及实现高性能的交互体验。

## Note 2020.07.31 加餐：

#### 通过 “函数式编程思想” 秒懂 Compose 流程机制

不知道在 “所以为什么会有数据驱动 UI 框架” 一节，我这样说有没有把话说明白？

> 数据驱动 UI 框架目前有两种实现方式，一种是函数式编程思想的设计，另一种是自动化代码生成的设计，但无论哪一种，归根结底是为了解决视图调用的一致性问题。
> 
> 这些是属于 **软件工程** 背景下的问题，我和多位程序员出身的、8 年以上工龄的创业者聊过这些。其中一位和我不约而同地提到了 “一致性问题”，而另一位提到了 “指数规模效应”（也即我所谓的 “破窗效应”）。
> 
> 这两个其实反映的是同一件事。就 “视图调用” 这事来说，一旦视图实例暴露，null 安全一致性问题 和 不受控制的指数规模效应 都将接踵而至。

然后注意看， 上述一节配图中的 render 方法，最终返回的 Widget 实例或者说 “布局树模型”，是作为入参，来传入到后台的机制中 在其内部完成 “视图树” 的更新和渲染。

也即，**作为开发者，我们能接触的就是 作为入口的 render 方法，和作为出口的 反映在触摸屏上的 肉眼可见、可触控的视图**（用于触发下一次的输入），除此之外，中间过程全被封装在后台，外部无法从旁干预，外部只能通过在入口处的输入 来在出口处获得对应的结果。如此来避免了 因中间过程被干预 而造成的各种 视图调用一致性问题。

数据驱动 UI 框架就是基于这样一个目的来实现的。

![Jetpack Compose UI 声明示例](https://images.xiaozhuanlan.com/photo/2021/64362a6c6198e8ace9043d354def8753.png)

Jetpack Compose UI 声明示例

> Jetpack Compose 和 SwiftUI 由于 DSL 封装抽象的太过了，乃至连返回布局树给后台的 render 方法都看不见（如上图，没有返回值，只有 [@Composable](https://xiaozhuanlan.com/u/Composable) 等注解） —— 这也是为什么 小伙伴们 **务必提前铺垫好 “函数式编程思想” 这一前置知识，如此方有机会越过表象，从函数式编程思想的角度出发来理解** 诸如上文提到的 “视图隐藏” 的写法。
> 
> 👆👆👆 划重点
> 
> 注：“一致性” 是 “软件工程安全” 领域的概念，对 “一致性” 概念不理解的小伙伴可参考[《架构组件 “一致性” 概念 全面解析》](https://xiaozhuanlan.com/topic/9340256871)。

## 综上

声明式 UI 是 “数据驱动 UI 框架” 的一种，**声明式 UI 的本质是函数式编程，且函数式编程的基石是纯函数**。

函数式编程的存在，主要是为了 **从范式层面彻底解决 过程的一致性问题**。

也即，函数式编程的特征是：**只有一个入口、并且 只有一个出口**，在运算过程中 **不包含与目的无关的隐含操作，也无法对运算过程 从旁干预**，从而 **确保了运算过程的可控、避免不可预期的状况的发生**。

数据驱动 主要是为了解决 **视图调用 乃至 视图实例 Null 安全的一致性问题**。

数据驱动的一大不可替代的好处是，**支持热重载、使布局动态编码的实时预览成为可能**。

函数式编程为了追求极致的软件工程设计，而先天地性能薄弱，因而**适合用于子线程中运行的背景任务**（RxJava 或 Java8 Stream 等数据层操作），而 **不适合对实时性要求较高的密集型任务**。

因此，将来的 Jetpack Compose 若是能对 调试和打包 采取 "分而治之" 的编译方式，兼顾 **编码时的 软工安全 + 实时预览** 和 **运行时的高性能**，那么新视图系统的全面更替 将指日可待。

> **便捷链接：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)
> 
> **视图系列文章：**
> 
> [重学安卓：从 0 到 1 “自定义视图” 完整爬坑顺序](https://xiaozhuanlan.com/topic/9361075842)
> 
> [重学安卓：滑动冲突 的快乐你不懂！](https://xiaozhuanlan.com/topic/8796215034)
> 
> [重学安卓：不如我们 从零开始设计一套 视图系统](https://xiaozhuanlan.com/topic/0162375948)
> 
> [重学安卓：百闻不如一见的 视图系统 架构全貌](https://xiaozhuanlan.com/topic/6420935178)
> 
> **[重学安卓：过目难忘 Android GUI 关系梳理](https://xiaozhuanlan.com/topic/2073915486)**
> 
> [重学安卓：一通百通 “声明式 UI” 扫盲干货](https://xiaozhuanlan.com/topic/2356748910)

## 版权声明

> Copyright © 2019-present KunMinX

文中提到的 “声明式 UI 是数据驱动 UI 框架的一种”、“声明式 UI 的本质是函数式编程”、“函数式编程的存在是为了 **从范式层面彻底解决 过程的一致性问题**”、**对之所以能通过 “纯函数乃至函数式编程” 来 “彻底解决一致性问题” 的原因的解析**、“数据驱动 UI 框架的本质 是在软件工程背景下 解决视图调用一致性问题”、“**DataBinding 严格模式**”、“DSL 预览和编译时分治” 等多处 **对特定现象及其本质的概括，均属于本人独立原创的成果**，本人对此享有最终解释权。

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。