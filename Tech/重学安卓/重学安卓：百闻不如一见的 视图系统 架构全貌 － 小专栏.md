---
created: 2021-10-13
source: https://xiaozhuanlan.com/topic/6420935178
author: 
---

# [重学安卓：百闻不如一见的 视图系统 架构全貌 － 小专栏](https://xiaozhuanlan.com/topic/6420935178)


> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

## 前言

很高兴见到你！

在上一期的[《不如我们 从零开始设计一套 视图系统》](https://xiaozhuanlan.com/topic/0162375948) 中，我们 全网独家地 以 **“所见即所得的 触控体验”** 为切入点，从零开始构思了一款视图系统，并自恰地解释了当下安卓视图系统中 某些细节之所以如此设计的缘由，相信阅读完这篇文章的小伙伴，对视图系统背景状况的印象 已跑赢了全网 90%的 移动开发者！

比如现在我们确知了：当我们谈论视图系统时，我们实际上是在谈论 **在冯诺依曼计算机的背景下的 人机交互系统**。因为一旦脱离了这个背景，就构不成 输入输出设备 的存在，也就谈不上对可编程内容的输入和输出，更不要说营造 符合用户直觉的 实时的 输入输出反馈。

所以，关于视图系统，就算遗忘了大部分细节，通过上一篇文章，我们也至少知道了，从宏观来看，**它主要就是包含 彼此独立且交替着的 输入和输出 这两大过程** —— 在此之前，如果我们对此不假思索、和普通用户一样去 **感知**（觉得 视图系统 “像光一样 具有波粒二象性”）、而不是 **思考**（知道所谓的 “实时响应” 只是计算机速度过快给人的错觉、实际上每一段触控都包含了 **无数次 顺序执行的** 输入 - 输出 - 输入 - 输出 ...），那么我们便无法真正理解和驾驭 视图系统 为我们做功。

## 文章目录一览

-   前言
-   **为什么要反思 视图系统**
-   作为差强人意的 Android 视图系统
-   视图系统 为什么要基于 C/S 架构
-   一睹 视图接口 和 视图服务 的抽象
-   当下 Android 视图系统 的怪状
-   综上
-   **Note 2020.1.29 加餐：**
    -   是让人 过目难忘 的 Android GUI 关系梳理

## 为什么要反思 视图系统

原因很简单，做客户端开发的，100% 要和视图系统打交道。

尽管许多技术层面的问题，从产品层面来看完全不是问题，

> 比如 [《从用户视角出发 反思自定义视图》](https://xiaozhuanlan.com/topic/9361075842) 一文提到的，尽量用普适的、现成的交互方案，这样用户的学习成本最小，不到万不得已的时候 不要自己去设计自定义视图，否则费力不讨好。
> 
> 又比如 Android 4.4 ~ 5.1 各种不成熟、各种毛病需要兼容，但从产品角度来看，上架的 App 完全可以考虑 6.0 起步，因为 2019 年还在用 4.4 系统的用户，**大概率不会是正经用户**
> 
> —— 从某位独立开发者分享的数据统计来看，Google Play 上的 4.4 用户 “贡献了” 78% 的差评和近乎为 0 的增值付费

然而唯有 正确地理解 一个系统 所服务的普适需求 乃至 **推知 和 确立** 该系统的必要构成，才能在关键时刻有条不紊地 **界定问题的边界、判定事物的归属**（比如你知道了 LayoutInflater 是视图排版的 **前置辅助工具**，那么在谈论具体的排版流程时，你便不会将其考虑进去，因为你明确地知道 它的边界、它的归属），从而 **不做无用功**地、毫不费力地迎刃而解

—— 你一定不希望 老板交代你任务时 一脸懵逼、不知从何下手，对吧。

## 作为差强人意的 Android 视图系统

所以 本来我是打算趁热打铁、接着上一篇 打下的认知基础，来继续深入对 排版过程的反思，

然而在我调研了一圈后发现，网上的文章多是 千篇一律地 贴代码、告诉你 how、how、how，就是不告诉你 why。由此引发了我 “走在路上，脑壳疼” 的难受。

比如，你知道 为什么要 **独立地存在** “测量” 的流程吗？是否能够提供案例，来证实这个过程的存在 确实是 某种场景下解决某种问题时的 不可替代？否则视图系统 为什么要存在这样的设计？

通过 LayoutParams 我能拿到对宽高的描述，那么我直接在 “布局” 环节根据描述来计算视图的 Left、Top、Right、Bottom、Height、Width 不也可以？（如我所料，Flutter 下就没有专门的测量流程）

就是这样烧脑的、但在我看来是不可绕过的关键，消耗了我大量的时间来思考和反复论证。

所以前几天有位读者私下感叹说，要是互联网上的每篇文章都能像 [《这样理解，你也能在 30 秒内讲明白 TCP 三次握手》](https://juejin.im/post/5cc15a376fb9a0322279223f) 一样，能用 "你听得见吗" "我听得见" "我也听得见" 让人秒懂三次握手的本质 该有多好，

> 实际上在我看来，并不是撰文、教书的人 **讲解方式** 的问题，而是 设计系统 和 撰写文档 的 通常不是同一个人。
> 
> 我们常常能在源码中看到精妙的设计，文档却常常只顾 how 而忽略了对 作为重中之重的 **如此设计的用意** 的介绍。

也即，上游的设计师 出于各种原因 没有出面解释，导致中游的教师或作者 需要花费大量的精力 才有一丝丝的机会正确地理解到。

并且，从生物代谢的角度来说，照本宣科、人云亦云，张口闭口 ACK、SYN（三次握手中的术语），显然是最节能的，尽管这样一来他们自己都蒙在鼓里、不知道自己究竟在讲些什么。

> [TQL](https://baike.baidu.com/item/tql/23642907)、[AWSL](https://baike.baidu.com/item/awsl/23306199)

于是，在 “现状如此” 的背景下，我决定将本篇文章分两部分讲，上半部分着重于反思各平台通用的 **视图系统架构实现 的全貌**，下半部分将对 安卓中的局部实现 作有选择地介绍。

在之前的 [《从用户视角出发 反思自定义视图》](https://xiaozhuanlan.com/topic/9361075842) 一文中已提到过：**源码的实现 绝非一蹴而就**，它是几十年下来不断演化、不断变更的结果，所以我们务必 首先基于反思 来为自己准备一把切入的钥匙，然后在这把钥匙的指引下 有目的地、点到为止地 到源码中**去确认**，而不是打一开始就盲目地一头栽进去 试图事无巨细地 全盘通吃。

好了 不多说了，下面让我们跟随 深度思考的脚步，**从抽象到具体**地 将视图系统架构实现的全貌 无痛地过一遍！

## 视图系统 为什么要基于 C/S 架构

无论是 Android、iOS、还是 MacOS、Windows、Linux，视图系统为了实现 输入和输出的完美协调，必然需要基于 C/S 架构。

为什么呢？

首先，排版结果的渲染 和 屏幕事件的接收，是通用的、且 **使用频率极高**，所以它应当在处于 支持高效率运行的、规避数据被篡改或破坏 的环境下运作，

根据大学时期我们学过的《操作系统》课程，我们能够得知，进程通常存在两大类：一类是用户进程，一类是系统进程。显然 **独立存在** 的系统进程 能够为上述需求提供理想的环境：**运行时无须申请任何权限、运行效率更高、且规避了内部数据惨遭外部篡改 而导致的运行结果不可预期的风险**。

> 由此我们的视图系统 便不得不 分为两部分 来运行，一部分是上述提到的，**常驻** 在系统进程中的 **视图服务**，另一部分就是 运行在 用户自己开启的用户进程中的 **视图接口（客户端）**，客户端的 排版结果 和 事件分发，都是通过这个“接口”去向 视图服务 传递和接收的。

![](https://images.xiaozhuanlan.com/photo/2019/0a96d6ecd3228da11741444527895df0.png)

除了上述提到的 **运行时高效、运行时安全**，一分为二的设计的另一个好处在于 **实现了效率和节省资源的平衡**：让频繁使用的底层服务 常驻、让随机使用的客户端 **随叫随到、用完即走**（关掉 App 的进程，进程申请的这部分资源 也就归还给系统了）。

> 所以 **至此我们确立了：视图系统需要 “一分为二” 的设计** ——
> 
> -   让使用频率极高的视图服务 常驻系统进程，以减少频繁创建进程导致的开销，以及由于是在系统进程中运行，因而效率更高、更安全。
>     
> -   与此同时，让客户端 在用户进程中生死存亡，从而达到即用即走、节省系统资源的目的。
>     
> 
> 而 **正是因为这个需要，造成了 视图接口 和 视图服务 分别处于不同的进程，从而有 IPC（Inter-Process Communication，进程间通信）的需要**。而该场景下效率最高的 IPC 通信方式是 RPC（Remote Procedure Call，远程过程调用）：一种 C/S 架构的实现，因而，视图系统需要基于 C/S 架构。

![](https://images.xiaozhuanlan.com/photo/2019/7051f528c05c3bbffa1d5e3864d4acc1.png)

简单地翻看一下安卓源码，如我所料，Stub 和 Session 等字样，几乎实锤了 安卓的确是用 RPC 方式来完成 该场景下的 IPC。

![](https://images.xiaozhuanlan.com/photo/2019/b5de6d71748e32baf35d990ac57c5d8f.png)

对 RPC 不熟悉的同学请 **不要慌**，可以自行搜索资料 或查阅相关书籍（例如 CSAPP）。

我们千万不要 死记硬背 RPC 的源码实现，这里分享一下 我看的好的 来自大学教材的小结。比起 源码的具体实现，对存在缘由的 抽象介绍 其实 **一目了然 而 易于理解**：

![](https://images.xiaozhuanlan.com/photo/2019/bca14ee433572a737b00cd4aedcbcfb2.png)

![](https://images.xiaozhuanlan.com/photo/2019/b7a85f2d8b3c64a0a4a525bb157aa708.png)

## 一睹 视图接口 和 视图服务 的抽象

所以，为了 传递排版结果 和 接收触控事件，在 视图接口端（客户端），必然需要存在 负责排版结果 和 接收触控事件 的 “窗口配置” 实体。

具体而言，一方面 它需要存在一套规则，来 **支持 对视图树的 递归**，从而完成 用于输出的 排版工作；另一方面，它需要存在一套接口（interface），来 **约定** 规格和入口，从而完成 输入事件 从服务到接口端 的传递。

（也即，该实体承担了 **排版属性的存储** 和 **窗口事件的代理** 两大职责）

![](https://images.xiaozhuanlan.com/photo/2019/2083d21a42e8153d82463fc0059de61c.png)

而在系统的另一端 —— 在视图服务中，我们需要 **根据 客户端传递的 窗口配置，来生成对应的 窗口实体**，从而 根据 **该实体所持有的 排版结果的描述，来最终渲染在屏幕上**。

![](https://images.xiaozhuanlan.com/photo/2019/a62e182f86acdcd0a873cc8500f21ec1.png)

所以从抽象设计上讲，一切都是如此地 一目了然、清晰简单。

> 至此我们从宏观上确知了，视图系统的 客户端和服务端，各自需要为 排版的管理 和 事件的传递 所做的规约和设计。

所以如果要 简单地给份源码实现的话，上述设计所包含的 类、职责 和 关系 大致如下：

窗口配置管理器，即 Java 类编写的 WindowManager，而 窗口配置，即持有 视图树等配置信息 以及包含事件代理 的 Window 类。

WindowManager 中管理着多个 Window，每个 Window 对应着 服务中生成的 真正的 窗口实例 RenderWindow（真正发生渲染的窗口）。当 屏幕输入触控事件时，事件会通过 RPC 往 Window 代理的 Callback 接口传递，紧随其后，Window 可调用自己内部实现的规则，去递归地执行视图树的排版。

如此一来，一切就都 干净明了、毫无疑问了。

## 当下 Android 视图系统 的怪状

然而 安卓平台的 旧版视图系统（区别于 Jetpack Compose）才不是这么设计的呢！

无论怎么看，这都像是个 “当初为了抢占市场而在 5 天时间内赶出来的、尔后经过十几年辗转反侧、缝缝补补的 有故事的大部头”，初次看源码的同学，一定明白我的意思：

首先，抛开 Activity 的窗口不讲，如果是单纯地添加一个窗口，比如浮动窗口，安卓是怎么做的呢？——WindowManager.addView() —— ？？？

那么窗口配置是怎么管理的呢？WindowManagerGlobal 中通过 3 个集合对 rootView、ViewRootImpl、Params 的管理来维持窗口配置的存在 —— 等等，为什么非得这么设计呢？？？为什么不是将 rootView、Params 作为 Window 类的成员、从而让 WindowManager 直接管理和遍历 Window 集合呢？

那么触控事件回调是怎么传递的呢？传给 ViewRootImpl 然后传给它的 DecorView 然后倒过来传给 PhoneWindow 再传给 Activity …… 等等，如果刚刚通过 3 个集合 虚构的玩意儿 才是窗口配置，那这里的 PhoneWindow 和 Window 又是什么鬼？（当然 现如今我们都知道 它这样绕上一圈是为了 Activity 能拿到事件、实现自上而下地分发，但 窗口配置 和 额外定义的 Window 类 存在歧义，**从软件工程的角度来看，这样的设计 为源码阅读者造成了困扰、为后来的源码修补者 埋下了一致性隐患**）

此外，如果丢开这一切不去理会，那么又有谁可以给出 自恰的解释：测量、布局、绘制，三大流程，其中的测量 为什么单独存在？

当然我们知道 测量的目标 是得到期望而非实际绘制用的宽高，可它的工作 不也可以在 布局流程中 完成的吗？独立出来是为了可以在某种情况下做到 **重复使用、节省资源 或 提升性能** ？

> 在 排版遍历 的源码中找到以下注释：
> 
> Implementation of weights from WindowManager.LayoutParams We just grow the dimensions as needed and re-measure if needs be.
> 
> 所以我暂且认为 是在某些情况下 有重复测量的需要，乃至这个流程被独立出来，单独调用。但除非有证据证明测量的耗时十分之少，否则始终有理由相信 存在更好的设计，比如 Flutter 就没有这样重复调用的情况。

是的，当初看这一块的源码的时候，就是这么难受。

正如上文我绘制的那些结构图一样，安卓平台视图系统关于 how 的抽象脉络，现如今在我脑海里也是清晰可见，但我不打算把它画出来，因为既然它 并没有热情地、主动地、自信地告诉我 如此设计的意义，那么我就将 这个问题的答案 交给时间。与此同时，我愿意等 Jetpack Compose，就像 iOS 同学在期待 SwiftUI 的成熟。

对 Android 平台在窗口配置管理上的实现、以及 排版流程的简练介绍 感兴趣的同学，可以参考《Android 开发艺术探索》这本书的第四章。尽管那么多年过去了，对排版流程的 how 的描述，还是这本书比较精炼。具体可见这篇读书笔记：

[https://blog.csdn.net/hfy8971613/article/details/102570685](https://blog.csdn.net/hfy8971613/article/details/102570685)

而对于 视图排版绘制流程中 Paint、Canvas 的使用，可以参考《HenCoder》自定义视图系列，其中提供了十分直观、详尽的图例和讲解，本文不再累述：

[https://juejin.im/post/5962a3746fb9a06ba2687226](https://juejin.im/post/5962a3746fb9a06ba2687226)

> 小记：有没有那么一瞬间，你会觉得，人类社会 **应用型技术的发展极其缓慢**？从深度思考的角度来看，视图系统该怎么设计、以及为什么如此设计，仿佛一早就尘埃落定、毫无疑问。可十二年过去了，Android 的视图系统仍然维持着 最初的那般 令人匪夷所思的模样。
> 
> Flutter 的存在无疑是个绝佳的尝试，至少它的存在本身遵循了开闭原则 —— 在不修改安卓平台的同时，另起炉灶 大刀阔斧地 尝试新的架构设计，以期有朝一日能够 **确立 和 使新的设计 在安卓平台落地**。

## 综上

视图系统的运行真相，是 输入和输出的交替运作、因交替时间间隔 小到足够满足人脑识别连贯影像的间隔要求，因而得以给人以 所见即所得 的主观感受。

同时，**为了达到 运行时高效、运行时安全，以及节省系统资源 的目的，视图系统天然地适合以 “一分为二” 的 方式编写 —— 在系统进程中运行 视图服务，在用户进程中运行 背靠视图接口的客户端**。

并且，既然需要分散在两种进程中运行，就有进程间通信的需要。又 **考虑到 RPC 在该场景下的高效，因而选择其作为 IPC 的实现方案** —— 至此 **确立了 视图系统从宏观来看 是基于 C/S 架构 编写**。

然后，对于客户端，最主要的设计是 窗口配置管理类 和 窗口配置实体类，前者管理着后者，后者既承担了 **提供 视图服务渲染窗口 所需的排版结果**、又承担了 **接收 从视图服务传来的 触控事件**，因而该实体类 **本质上是** 视图服务中渲染的那个窗口 在客户端中的 **一个代理**。

此外，对于安卓平台 对客户端视图接口 的实现，我暂时持保留意见，因为这样的设计 似乎迟早要被 合乎其理的设计 所替代，更因为 凡事我唯有搞懂了 why、且确信其如此设计的合理性，才会义无反顾地为其发声。

因而，就算要去深究安卓平台的实现，通过上文对 视图系统架构设计的构思，相信宏观上的流程和结构 我们已经事先做到了心中有数。

剩下的，不如我们交给时间，结合前面几篇提到的 用户体验场景，多多练习，训练自己在可视化编程领域的才干~

## Note 2020.1.29 加餐：

### 是让人 过目难忘 的 Android GUI 关系梳理

如果此前小伙伴们对 Android 中 View、Drawable、Layout、Inflater、include、merge、ViewStub 等等概念的 **本质、边界 和 关系** 云里雾里、不知道从何下手，

或是涉足过 PhoneWindow、ViewRootImpl 等源码，且吃够了错综复杂、找不到头绪的苦，推荐拓展阅读下一篇 [《是让人 过目难忘 的 Android GUI 关系梳理》](https://xiaozhuanlan.com/topic/2073915486) ，

该篇以独家的 “二分法视角”，兵分两路地揭示 PhoneWindow、ViewRootImpl 在可视化交互系统中所处的环节和各自的本质，感兴趣的小伙伴可趁热打铁，获得双倍的快乐。

> **便捷链接：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)
> 
> **视图系列文章：**
> 
> [重学安卓：从 0 到 1 “自定义视图” 完整爬坑顺序](https://xiaozhuanlan.com/topic/9361075842)
> 
> [重学安卓：滑动冲突 的快乐你不懂！](https://xiaozhuanlan.com/topic/8796215034)
> 
> [重学安卓：不如我们 从零开始设计一套 视图系统](https://xiaozhuanlan.com/topic/0162375948)
> 
> [重学安卓：百闻不如一见的 视图系统 架构全貌](https://xiaozhuanlan.com/topic/6420935178)
> 
> **[重学安卓：过目难忘 Android GUI 关系梳理](https://xiaozhuanlan.com/topic/2073915486)**
> 
> [重学安卓：一通百通 “声明式 UI” 扫盲干货](https://xiaozhuanlan.com/topic/2356748910)

## 版权声明

> Copyright © 2019-present KunMinX

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。

> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

## 前言

很高兴见到你！

在上一期的[《不如我们 从零开始设计一套 视图系统》](https://xiaozhuanlan.com/topic/0162375948) 中，我们 全网独家地 以 **“所见即所得的 触控体验”** 为切入点，从零开始构思了一款视图系统，并自恰地解释了当下安卓视图系统中 某些细节之所以如此设计的缘由，相信阅读完这篇文章的小伙伴，对视图系统背景状况的印象 已跑赢了全网 90%的 移动开发者！

比如现在我们确知了：当我们谈论视图系统时，我们实际上是在谈论 **在冯诺依曼计算机的背景下的 人机交互系统**。因为一旦脱离了这个背景，就构不成 输入输出设备 的存在，也就谈不上对可编程内容的输入和输出，更不要说营造 符合用户直觉的 实时的 输入输出反馈。

所以，关于视图系统，就算遗忘了大部分细节，通过上一篇文章，我们也至少知道了，从宏观来看，**它主要就是包含 彼此独立且交替着的 输入和输出 这两大过程** —— 在此之前，如果我们对此不假思索、和普通用户一样去 **感知**（觉得 视图系统 “像光一样 具有波粒二象性”）、而不是 **思考**（知道所谓的 “实时响应” 只是计算机速度过快给人的错觉、实际上每一段触控都包含了 **无数次 顺序执行的** 输入 - 输出 - 输入 - 输出 ...），那么我们便无法真正理解和驾驭 视图系统 为我们做功。

## 文章目录一览

-   前言
-   **为什么要反思 视图系统**
-   作为差强人意的 Android 视图系统
-   视图系统 为什么要基于 C/S 架构
-   一睹 视图接口 和 视图服务 的抽象
-   当下 Android 视图系统 的怪状
-   综上
-   **Note 2020.1.29 加餐：**
    -   是让人 过目难忘 的 Android GUI 关系梳理

## 为什么要反思 视图系统

原因很简单，做客户端开发的，100% 要和视图系统打交道。

尽管许多技术层面的问题，从产品层面来看完全不是问题，

> 比如 [《从用户视角出发 反思自定义视图》](https://xiaozhuanlan.com/topic/9361075842) 一文提到的，尽量用普适的、现成的交互方案，这样用户的学习成本最小，不到万不得已的时候 不要自己去设计自定义视图，否则费力不讨好。
> 
> 又比如 Android 4.4 ~ 5.1 各种不成熟、各种毛病需要兼容，但从产品角度来看，上架的 App 完全可以考虑 6.0 起步，因为 2019 年还在用 4.4 系统的用户，**大概率不会是正经用户**
> 
> —— 从某位独立开发者分享的数据统计来看，Google Play 上的 4.4 用户 “贡献了” 78% 的差评和近乎为 0 的增值付费

然而唯有 正确地理解 一个系统 所服务的普适需求 乃至 **推知 和 确立** 该系统的必要构成，才能在关键时刻有条不紊地 **界定问题的边界、判定事物的归属**（比如你知道了 LayoutInflater 是视图排版的 **前置辅助工具**，那么在谈论具体的排版流程时，你便不会将其考虑进去，因为你明确地知道 它的边界、它的归属），从而 **不做无用功**地、毫不费力地迎刃而解

—— 你一定不希望 老板交代你任务时 一脸懵逼、不知从何下手，对吧。

## 作为差强人意的 Android 视图系统

所以 本来我是打算趁热打铁、接着上一篇 打下的认知基础，来继续深入对 排版过程的反思，

然而在我调研了一圈后发现，网上的文章多是 千篇一律地 贴代码、告诉你 how、how、how，就是不告诉你 why。由此引发了我 “走在路上，脑壳疼” 的难受。

比如，你知道 为什么要 **独立地存在** “测量” 的流程吗？是否能够提供案例，来证实这个过程的存在 确实是 某种场景下解决某种问题时的 不可替代？否则视图系统 为什么要存在这样的设计？

通过 LayoutParams 我能拿到对宽高的描述，那么我直接在 “布局” 环节根据描述来计算视图的 Left、Top、Right、Bottom、Height、Width 不也可以？（如我所料，Flutter 下就没有专门的测量流程）

就是这样烧脑的、但在我看来是不可绕过的关键，消耗了我大量的时间来思考和反复论证。

所以前几天有位读者私下感叹说，要是互联网上的每篇文章都能像 [《这样理解，你也能在 30 秒内讲明白 TCP 三次握手》](https://juejin.im/post/5cc15a376fb9a0322279223f) 一样，能用 "你听得见吗" "我听得见" "我也听得见" 让人秒懂三次握手的本质 该有多好，

> 实际上在我看来，并不是撰文、教书的人 **讲解方式** 的问题，而是 设计系统 和 撰写文档 的 通常不是同一个人。
> 
> 我们常常能在源码中看到精妙的设计，文档却常常只顾 how 而忽略了对 作为重中之重的 **如此设计的用意** 的介绍。

也即，上游的设计师 出于各种原因 没有出面解释，导致中游的教师或作者 需要花费大量的精力 才有一丝丝的机会正确地理解到。

并且，从生物代谢的角度来说，照本宣科、人云亦云，张口闭口 ACK、SYN（三次握手中的术语），显然是最节能的，尽管这样一来他们自己都蒙在鼓里、不知道自己究竟在讲些什么。

> [TQL](https://baike.baidu.com/item/tql/23642907)、[AWSL](https://baike.baidu.com/item/awsl/23306199)

于是，在 “现状如此” 的背景下，我决定将本篇文章分两部分讲，上半部分着重于反思各平台通用的 **视图系统架构实现 的全貌**，下半部分将对 安卓中的局部实现 作有选择地介绍。

在之前的 [《从用户视角出发 反思自定义视图》](https://xiaozhuanlan.com/topic/9361075842) 一文中已提到过：**源码的实现 绝非一蹴而就**，它是几十年下来不断演化、不断变更的结果，所以我们务必 首先基于反思 来为自己准备一把切入的钥匙，然后在这把钥匙的指引下 有目的地、点到为止地 到源码中**去确认**，而不是打一开始就盲目地一头栽进去 试图事无巨细地 全盘通吃。

好了 不多说了，下面让我们跟随 深度思考的脚步，**从抽象到具体**地 将视图系统架构实现的全貌 无痛地过一遍！

## 视图系统 为什么要基于 C/S 架构

无论是 Android、iOS、还是 MacOS、Windows、Linux，视图系统为了实现 输入和输出的完美协调，必然需要基于 C/S 架构。

为什么呢？

首先，排版结果的渲染 和 屏幕事件的接收，是通用的、且 **使用频率极高**，所以它应当在处于 支持高效率运行的、规避数据被篡改或破坏 的环境下运作，

根据大学时期我们学过的《操作系统》课程，我们能够得知，进程通常存在两大类：一类是用户进程，一类是系统进程。显然 **独立存在** 的系统进程 能够为上述需求提供理想的环境：**运行时无须申请任何权限、运行效率更高、且规避了内部数据惨遭外部篡改 而导致的运行结果不可预期的风险**。

> 由此我们的视图系统 便不得不 分为两部分 来运行，一部分是上述提到的，**常驻** 在系统进程中的 **视图服务**，另一部分就是 运行在 用户自己开启的用户进程中的 **视图接口（客户端）**，客户端的 排版结果 和 事件分发，都是通过这个“接口”去向 视图服务 传递和接收的。

![](https://images.xiaozhuanlan.com/photo/2019/0a96d6ecd3228da11741444527895df0.png)

除了上述提到的 **运行时高效、运行时安全**，一分为二的设计的另一个好处在于 **实现了效率和节省资源的平衡**：让频繁使用的底层服务 常驻、让随机使用的客户端 **随叫随到、用完即走**（关掉 App 的进程，进程申请的这部分资源 也就归还给系统了）。

> 所以 **至此我们确立了：视图系统需要 “一分为二” 的设计** ——
> 
> -   让使用频率极高的视图服务 常驻系统进程，以减少频繁创建进程导致的开销，以及由于是在系统进程中运行，因而效率更高、更安全。
>     
> -   与此同时，让客户端 在用户进程中生死存亡，从而达到即用即走、节省系统资源的目的。
>     
> 
> 而 **正是因为这个需要，造成了 视图接口 和 视图服务 分别处于不同的进程，从而有 IPC（Inter-Process Communication，进程间通信）的需要**。而该场景下效率最高的 IPC 通信方式是 RPC（Remote Procedure Call，远程过程调用）：一种 C/S 架构的实现，因而，视图系统需要基于 C/S 架构。

![](https://images.xiaozhuanlan.com/photo/2019/7051f528c05c3bbffa1d5e3864d4acc1.png)

简单地翻看一下安卓源码，如我所料，Stub 和 Session 等字样，几乎实锤了 安卓的确是用 RPC 方式来完成 该场景下的 IPC。

![](https://images.xiaozhuanlan.com/photo/2019/b5de6d71748e32baf35d990ac57c5d8f.png)

对 RPC 不熟悉的同学请 **不要慌**，可以自行搜索资料 或查阅相关书籍（例如 CSAPP）。

我们千万不要 死记硬背 RPC 的源码实现，这里分享一下 我看的好的 来自大学教材的小结。比起 源码的具体实现，对存在缘由的 抽象介绍 其实 **一目了然 而 易于理解**：

![](https://images.xiaozhuanlan.com/photo/2019/bca14ee433572a737b00cd4aedcbcfb2.png)

![](https://images.xiaozhuanlan.com/photo/2019/b7a85f2d8b3c64a0a4a525bb157aa708.png)

## 一睹 视图接口 和 视图服务 的抽象

所以，为了 传递排版结果 和 接收触控事件，在 视图接口端（客户端），必然需要存在 负责排版结果 和 接收触控事件 的 “窗口配置” 实体。

具体而言，一方面 它需要存在一套规则，来 **支持 对视图树的 递归**，从而完成 用于输出的 排版工作；另一方面，它需要存在一套接口（interface），来 **约定** 规格和入口，从而完成 输入事件 从服务到接口端 的传递。

（也即，该实体承担了 **排版属性的存储** 和 **窗口事件的代理** 两大职责）

![](https://images.xiaozhuanlan.com/photo/2019/2083d21a42e8153d82463fc0059de61c.png)

而在系统的另一端 —— 在视图服务中，我们需要 **根据 客户端传递的 窗口配置，来生成对应的 窗口实体**，从而 根据 **该实体所持有的 排版结果的描述，来最终渲染在屏幕上**。

![](https://images.xiaozhuanlan.com/photo/2019/a62e182f86acdcd0a873cc8500f21ec1.png)

所以从抽象设计上讲，一切都是如此地 一目了然、清晰简单。

> 至此我们从宏观上确知了，视图系统的 客户端和服务端，各自需要为 排版的管理 和 事件的传递 所做的规约和设计。

所以如果要 简单地给份源码实现的话，上述设计所包含的 类、职责 和 关系 大致如下：

窗口配置管理器，即 Java 类编写的 WindowManager，而 窗口配置，即持有 视图树等配置信息 以及包含事件代理 的 Window 类。

WindowManager 中管理着多个 Window，每个 Window 对应着 服务中生成的 真正的 窗口实例 RenderWindow（真正发生渲染的窗口）。当 屏幕输入触控事件时，事件会通过 RPC 往 Window 代理的 Callback 接口传递，紧随其后，Window 可调用自己内部实现的规则，去递归地执行视图树的排版。

如此一来，一切就都 干净明了、毫无疑问了。

## 当下 Android 视图系统 的怪状

然而 安卓平台的 旧版视图系统（区别于 Jetpack Compose）才不是这么设计的呢！

无论怎么看，这都像是个 “当初为了抢占市场而在 5 天时间内赶出来的、尔后经过十几年辗转反侧、缝缝补补的 有故事的大部头”，初次看源码的同学，一定明白我的意思：

首先，抛开 Activity 的窗口不讲，如果是单纯地添加一个窗口，比如浮动窗口，安卓是怎么做的呢？——WindowManager.addView() —— ？？？

那么窗口配置是怎么管理的呢？WindowManagerGlobal 中通过 3 个集合对 rootView、ViewRootImpl、Params 的管理来维持窗口配置的存在 —— 等等，为什么非得这么设计呢？？？为什么不是将 rootView、Params 作为 Window 类的成员、从而让 WindowManager 直接管理和遍历 Window 集合呢？

那么触控事件回调是怎么传递的呢？传给 ViewRootImpl 然后传给它的 DecorView 然后倒过来传给 PhoneWindow 再传给 Activity …… 等等，如果刚刚通过 3 个集合 虚构的玩意儿 才是窗口配置，那这里的 PhoneWindow 和 Window 又是什么鬼？（当然 现如今我们都知道 它这样绕上一圈是为了 Activity 能拿到事件、实现自上而下地分发，但 窗口配置 和 额外定义的 Window 类 存在歧义，**从软件工程的角度来看，这样的设计 为源码阅读者造成了困扰、为后来的源码修补者 埋下了一致性隐患**）

此外，如果丢开这一切不去理会，那么又有谁可以给出 自恰的解释：测量、布局、绘制，三大流程，其中的测量 为什么单独存在？

当然我们知道 测量的目标 是得到期望而非实际绘制用的宽高，可它的工作 不也可以在 布局流程中 完成的吗？独立出来是为了可以在某种情况下做到 **重复使用、节省资源 或 提升性能** ？

> 在 排版遍历 的源码中找到以下注释：
> 
> Implementation of weights from WindowManager.LayoutParams We just grow the dimensions as needed and re-measure if needs be.
> 
> 所以我暂且认为 是在某些情况下 有重复测量的需要，乃至这个流程被独立出来，单独调用。但除非有证据证明测量的耗时十分之少，否则始终有理由相信 存在更好的设计，比如 Flutter 就没有这样重复调用的情况。

是的，当初看这一块的源码的时候，就是这么难受。

正如上文我绘制的那些结构图一样，安卓平台视图系统关于 how 的抽象脉络，现如今在我脑海里也是清晰可见，但我不打算把它画出来，因为既然它 并没有热情地、主动地、自信地告诉我 如此设计的意义，那么我就将 这个问题的答案 交给时间。与此同时，我愿意等 Jetpack Compose，就像 iOS 同学在期待 SwiftUI 的成熟。

对 Android 平台在窗口配置管理上的实现、以及 排版流程的简练介绍 感兴趣的同学，可以参考《Android 开发艺术探索》这本书的第四章。尽管那么多年过去了，对排版流程的 how 的描述，还是这本书比较精炼。具体可见这篇读书笔记：

[https://blog.csdn.net/hfy8971613/article/details/102570685](https://blog.csdn.net/hfy8971613/article/details/102570685)

而对于 视图排版绘制流程中 Paint、Canvas 的使用，可以参考《HenCoder》自定义视图系列，其中提供了十分直观、详尽的图例和讲解，本文不再累述：

[https://juejin.im/post/5962a3746fb9a06ba2687226](https://juejin.im/post/5962a3746fb9a06ba2687226)

> 小记：有没有那么一瞬间，你会觉得，人类社会 **应用型技术的发展极其缓慢**？从深度思考的角度来看，视图系统该怎么设计、以及为什么如此设计，仿佛一早就尘埃落定、毫无疑问。可十二年过去了，Android 的视图系统仍然维持着 最初的那般 令人匪夷所思的模样。
> 
> Flutter 的存在无疑是个绝佳的尝试，至少它的存在本身遵循了开闭原则 —— 在不修改安卓平台的同时，另起炉灶 大刀阔斧地 尝试新的架构设计，以期有朝一日能够 **确立 和 使新的设计 在安卓平台落地**。

## 综上

视图系统的运行真相，是 输入和输出的交替运作、因交替时间间隔 小到足够满足人脑识别连贯影像的间隔要求，因而得以给人以 所见即所得 的主观感受。

同时，**为了达到 运行时高效、运行时安全，以及节省系统资源 的目的，视图系统天然地适合以 “一分为二” 的 方式编写 —— 在系统进程中运行 视图服务，在用户进程中运行 背靠视图接口的客户端**。

并且，既然需要分散在两种进程中运行，就有进程间通信的需要。又 **考虑到 RPC 在该场景下的高效，因而选择其作为 IPC 的实现方案** —— 至此 **确立了 视图系统从宏观来看 是基于 C/S 架构 编写**。

然后，对于客户端，最主要的设计是 窗口配置管理类 和 窗口配置实体类，前者管理着后者，后者既承担了 **提供 视图服务渲染窗口 所需的排版结果**、又承担了 **接收 从视图服务传来的 触控事件**，因而该实体类 **本质上是** 视图服务中渲染的那个窗口 在客户端中的 **一个代理**。

此外，对于安卓平台 对客户端视图接口 的实现，我暂时持保留意见，因为这样的设计 似乎迟早要被 合乎其理的设计 所替代，更因为 凡事我唯有搞懂了 why、且确信其如此设计的合理性，才会义无反顾地为其发声。

因而，就算要去深究安卓平台的实现，通过上文对 视图系统架构设计的构思，相信宏观上的流程和结构 我们已经事先做到了心中有数。

剩下的，不如我们交给时间，结合前面几篇提到的 用户体验场景，多多练习，训练自己在可视化编程领域的才干~

## Note 2020.1.29 加餐：

### 是让人 过目难忘 的 Android GUI 关系梳理

如果此前小伙伴们对 Android 中 View、Drawable、Layout、Inflater、include、merge、ViewStub 等等概念的 **本质、边界 和 关系** 云里雾里、不知道从何下手，

或是涉足过 PhoneWindow、ViewRootImpl 等源码，且吃够了错综复杂、找不到头绪的苦，推荐拓展阅读下一篇 [《是让人 过目难忘 的 Android GUI 关系梳理》](https://xiaozhuanlan.com/topic/2073915486) ，

该篇以独家的 “二分法视角”，兵分两路地揭示 PhoneWindow、ViewRootImpl 在可视化交互系统中所处的环节和各自的本质，感兴趣的小伙伴可趁热打铁，获得双倍的快乐。

> **便捷链接：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)
> 
> **视图系列文章：**
> 
> [重学安卓：从 0 到 1 “自定义视图” 完整爬坑顺序](https://xiaozhuanlan.com/topic/9361075842)
> 
> [重学安卓：滑动冲突 的快乐你不懂！](https://xiaozhuanlan.com/topic/8796215034)
> 
> [重学安卓：不如我们 从零开始设计一套 视图系统](https://xiaozhuanlan.com/topic/0162375948)
> 
> [重学安卓：百闻不如一见的 视图系统 架构全貌](https://xiaozhuanlan.com/topic/6420935178)
> 
> **[重学安卓：过目难忘 Android GUI 关系梳理](https://xiaozhuanlan.com/topic/2073915486)**
> 
> [重学安卓：一通百通 “声明式 UI” 扫盲干货](https://xiaozhuanlan.com/topic/2356748910)

## 版权声明

> Copyright © 2019-present KunMinX

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。