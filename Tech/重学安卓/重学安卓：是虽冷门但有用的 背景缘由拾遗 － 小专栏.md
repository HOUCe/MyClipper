---
created: 2021-10-13
source: https://xiaozhuanlan.com/topic/0378514692
author: 
---

# [重学安卓：是虽冷门但有用的 背景缘由拾遗 － 小专栏](https://xiaozhuanlan.com/topic/0378514692)


> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

## 前言

在过去 10 个月里，我们通过《视图控制器》系列文章，确知了 Activity / Fragment 各自的 **背景由来、设计依据、职责边界**，以及它们在具体使用中 所涉及的高频场景，如 **页面加载、页面重建、页面跳转、页面通信** 等。

紧接着，通过《标准化开发模式》系列文章，我们确知了在 以多人协作为背景 的软件工程下，基于可视化内容开发的场景中 所面临的诸多 **容易造成不可预期错误** 的 **一致性问题**，如 页面元素涉及 **生命周期管理 的一致性问题**；页面重建涉及的 **状态恢复**；数据请求 和 页面通信 涉及的 **事件源一致性问题**；视图控件刷新时涉及的 **视图调用的一致性问题** 等。

再然后，在《视图系统》系列文章中，我们第一次冲出 Android 和技术的舒适圈，跨界追根溯源地找寻软件开发的终极答案、站在源码设计师的角度 来设计和重新认识视图系统，并最终以架构师的身份确知了 **“声明式 UI” 框架**的本质 及其在软件工程背景下 不可替代的意义。

那么在经过长达 10 个月的演练后，我相信在座的各位 对如何深刻理解和掌握一门技术，已然做到心中有数、如囊中取物。

## 文章目录一览

-   前言
    
-   软件开发只是作为末端的实现
    
    -   注意力要花在刀刃上
    -   总有比刀刃更刀刃的刀刃
    -   饭后甜点不能当主食吃
-   [Service 老矣，尚能饭否？](https://xiaozhuanlan.com/topic/0378514692#service)
    
-   [你 Broadcast 还是你 Broadcast](https://xiaozhuanlan.com/topic/0378514692#broadcast)
    
-   [出师未捷身先死的 WorkManager](https://xiaozhuanlan.com/topic/0378514692#workmanager)
    

## 软件开发只是作为末端的实现

所以今天分享的这一篇《“虽冷门但有用” 的背景缘由拾遗》，主要有以下三个考虑：

### 1.注意力要花在刀刃上

但凡有心的小伙伴都会感觉到，不同于互联网上的多数技术专栏，《重学安卓》专栏始终秉持着 **宁缺毋滥 且体系化、精进化** 的模式经营 —— 从不疯狂扩充文章，反而小心翼翼地控制数量、不断打磨和翻新旧文章 —— 做这么一件看似费力不讨好的事。

为什么呢？

曾有位小伙伴在评论区的留言揭示了真相 —— 互联网上的信息实在太多了，与此同时，我们却对自己 真正需要的东西 知之甚少，乃至于害怕投入注意力去付出，因为看不见付出与收益之间的直接联系。

是的，在面向公众写作之初，便清醒地认识到这一点，**如果不能 完全站在目标读者的角度 去提供内容服务，那么不仅不能让读者感觉良好，反而徒添困扰、选择困难**。

这就好比米其林餐厅的法餐，深夜里当你看到这张图时，你是不是有种 “看起来很小巧紧致、但吃不饱” 的感觉呢？

![图片来自 Unsplash](https://images.xiaozhuanlan.com/photo/2021/59175880f61c5fe2c7697815a6fa335a.jpeg)

图片来自 Unsplash

那就对了，正因为它是那么紧致的一小口、而且口味看起来又很好，所以你会放心大胆地一口吃下去，因为这样的注意力付出 对你来说 实在是太容易了、一点也不亏，甚至意犹未尽。

在这个基础上，要是必不可少的每样都能来一点，那么今天这趟就来得太值了、回忆满满。

与之相对的是快餐。

快餐的习惯是，一上来就给你满满的一盘，比如青椒炒肉，你要的肉，它给的很少很少（背景缘由 绝口不提），倒是青椒很多很多（通篇贴源码）。看起来好大一盘、看起来完全不会感觉吃不饱，但也提不起食欲、下不了口。

### 2.总有比刀刃更刀刃的刀刃

尽管目前我们已品尝过《重学安卓》 3 个系列的 “法餐”，而且尽管这 3 个系列已是精挑细选、克制 克制 再克制的结果，我仍然不能保证，没有比它更为紧致和好味的餐点。

我们的生命总长度是有限的，所以 **总有些食物是比其他食物更紧致、更好味、更值得优先为我们所体验，但我们甚至连 它们是谁、叫什么、在人生中本该有的地位 都一无所知。**

在 [《滑动冲突的快乐你不懂》](https://xiaozhuanlan.com/topic/8796215034) 一文中，我们冲出技术的舒适圈，去到更为贴近本源的 产品设计的领域 找到了关于某些 普适现象 的答案，其中谈到的 我自己悟出的产品设计原则 —— “**用户体验的目标之一 是维持操作的连贯性**”，已通过了时间的考验 —— 至今仍有用户不吝吹爆 “[《最佳实践》](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice) 项目可能是他们用过的 ‘最流畅’ 的软件”。

![](https://images.xiaozhuanlan.com/photo/2020/25b914fae64aebf319712cb008b218e9.png)

![](https://images.xiaozhuanlan.com/photo/2020/72e99969006937bd2fb3de1d39922941.png)

—— 用户知道 MVVM 和 MVP 甚至 MVC 的区别吗？知道 Jetpack MVVM 在 快速、稳定、减少不可预期错误地开发中 起到的不可替代的作用吗？

很显然，用户不知道也不关心。但一个懂得 “连贯性” 原则的、基于 MVC 开发的软件，和一个基于关注点分离的 Jetpack MVVM、 但对产品设计毫无概念的软件，在用户眼里，哪个看起来 “更健壮、更有技术” 呢？

### 3.饭后甜点不能当主食吃

在 [《深度思考原则》](https://xiaozhuanlan.com/topic/9837051426) 篇，我们确立了一条超级普适的认知原则，可以说，《重学安卓》专栏的每篇文章都是 不遗余力地 在贯彻这条核心原则：

> 任何技术都绝非凭空存在，一项技术的存在，必有其存在缘由 —— 为了在特定场景下 解决某个或某些问题。
> 
> 换言之，认识技术，必从认识背景做起 —— **当我们确知了某项技术在特定场景下的不可替代，便是抓住了该技术的本质**。

因此，当网上还有人在质疑 “LiveData 本来就不是这么用的”、攀比 “SharedViewModel 和 LiveDataBus 哪家强”、吐槽 “DataBinding 不好用” 时，睿智的你 根本不会想要参与 这些无谓的争议，因为一切都是背景说了算 —— 脱离了对潜在问题的确知，任何凭主观喜好、凭感觉的说法都是 画地为牢、瞎扯淡。

> 能 get 到的背景有多少，对技术的把握就能有多到位，就这么简单。

举个例子：将 LiveData 用于页面通信（发送事件）的场景，存在 “数据倒灌” 的现象，网上立马有人跳出来质疑，说 LiveData 本来就不该这么用。

然而事实上，关于 页面通信的场景，我们能拼凑出的背景主要有哪几块呢？主要包括：

> -   事件的观察者是页面，但页面可能非激活状态、甚至处于被销毁状态，那么此时在消息回调中接触页面成员 将有生命周期安全的隐患。
>     
> -   事件的观察者必须是页面，对页面的消息推送，不能让其他地方 能够监听和收到 不可预期的推送。
>     
> -   事件的发送者必须来自唯一可信源，最好是在断点调试时，能方便地直接从内存中找到对象、从而追溯到事件源。
>     

是的，面临的背景，至少就有这 3 块，毫不谦虚地说，LiveData + ViewModel 的组合，是目前为止（2020.4）唯一能 超低成本地胜任 上述 3 个问题的解决方案。因而问题也就进一步转化为解决 LiveData 的粘性问题，让它在 页面通信的场景下能符合预期地发生推送。

> 上述主要想要揭示的是，**认识背景** 的重要性和优先级。

与此同时，关于 “第 3 点考虑”，我主要想表达的是，有些技术因不再适应 **背景的组合变化**，而处于被边缘 甚至被淘汰的境地，所以，尽管在 [《认知地图》](https://xiaozhuanlan.com/topic/9074561823) 篇的文末，我分享了一张《基本功地图》，但并不是其中提到的每一项技术点，我都会专门为它 cook 一篇。

相比之下，借 对技术点的思考 来 **明确对背景的掌握，从而能够在 不断被组合的背景认知 的引导下，迅速找到当下综合成本最低的实现**，实在是再好不过了。

而且带着对背景的确知，将来无论是迁移技术栈到 iOS 或是 Flutter，都是轻而易举。对方平台可能没有 Activity、没有 Fragment、没有 LiveData、也没有 DataBinding，但 **出于对背景的确知，相信你很快就能 因地制宜地找到相关的技术点 来解决问题**。

于是，接下来你将看到，那些因不再能够适应变化、而在核心竞争力上日益缩水的技术点，被主厨我做成了更小、更紧致的饭后甜点 —— 请慢用。

![图片来自 Unsplash](https://images.xiaozhuanlan.com/photo/2021/c2df9f9613dcea1c77f7bb1b99b8db98.jpeg)

图片来自 Unsplash

## Service 老矣，尚能饭否？

曾有从后端转 移动端 的小伙伴私下询问，这个 Service 到底什么来头呀，它和线程到底什么关系呀，到底该不该用呀 …

网上关于 Service 的 “万字长文” 多如牛毛，却鲜有文章愿意费一丝丝笔墨来介绍 背景缘由、职责边界，这使得教程写得再好，看过也没有印象、用不起来，

作为对比，让我们实操 “深度思考” 来看一下：

Android 四大组件其实是 2008 年的 SDK 1.0 起同时提供的，之所以要有 Service，主要是考虑到这样的场景：

> -   有些任务的生命周期 必须独立于任何一个页面、并且其中的数据 能够为多个页面所共享，比如 “返回下载进度” 的场景。
>     
> -   而且光是生命周期独立还不够，当退出 App 界面时，App 进程还需在后台存活，直到把任务做完。
>     
> -   如果 App 存在多进程，还要支持进程间通信、让数据跨进程访问。
>     

关于第一点，其实单例也可以做到，对吧，但单例的生命周期与 Application 持平，无法走销毁流程。

关于第二点，在 [《Activity 生命周期的 3 个辟谣》](https://xiaozhuanlan.com/topic/0213584967) 一节我们提到过 “进程模式”，显然 Service 能使后台 App 处于 服务模式，而 Foreground-Service（前台服务） 甚至可以让 App 处于 可见模式、让 App 在官方原版系统中，不会被系统回收。

关于第三点，Service 是个跨进程组件，在为来自多个进程的 Activity 提供 跨进程数据访问 的场景下，没有谁比 Service 的使用成本更低，对吧。

所以，至此，我们确知了 Service 的存在缘由：

> -   为了支持生命周期独立于页面的任务的执行，
>     
> -   为了实现 App 后台保活，
>     
> -   为了方便跨进程数据访问，
>     

于是它的边界仅限于：

**为任务提供一个 生命周期独立于页面 的上下文空间，而不是提供一个线程**。当然，为了方便，官方在 Service 的基础上又封装了一个 IntentService，专用于 自动开启一个线程 且任务执行完自行销毁服务 的场景。

但，作为一个跨进程组件，它是不是有点 “重” 了？如果每每有任务，比如数据请求的任务，就需要开一个 Service 的话。

所以关于第一点，更轻量、更灵活的替代品出现了 —— ViewModel，针对性地提供 独立于页面生命周期 的服务 —— 对于 Fragment 作用域的 ViewModel，能够一对一地在 Fragment 重建时提供状态恢复的服务；对于 Activity 或 Application 作用域的 ViewModel，能够跨 Fragment 地提供页面通信服务。

关于第二点，由于国内监管不严，流氓软件各显神通、相互唤醒和保活，在这样的背景下，国产 ROM 厂商出于流畅和省电的考虑，而迫使保活规则失效。（当然，应对办法也不是没有，比如 通过文案引导用户在 “最近访问列表” 中为程序添加 “清理锁”，并且关闭 App 的 “省电优化”）

所以实际上，如果要说 Service 还有什么不可替代的特点的话，就只剩第三点了 ——

**在 跨进程数据访问 的场景下，请想起它**。

## 你 Broadcast 还是你 Broadcast

相比 Service，Broadcast 的近况其实还是要好一点。

Broadcast 的存在，主要是为了 发送和接收 跨进程的通知。

比如你为 前台服务 写一个 RemoteView 通知栏组件，为了在 App 退出后还能在通知栏运作，它被设计为是独立于 App 进程而生存的，所以这个时候，无论是 App 主体通知 RemoteView 刷新，还是 RemoteView 的点击通知 App 主体的刷新，这么一来二去的，这种跨进程通信的场景，都是只能靠 Broadcast 来完成。

与此同时，Broadcast 的竞争力，主要是在以下两个场景缩水了：

1.App 本地通信的场景。现如今，我们都在 MVVM 的开发模式下，提倡基于 “唯一可信源” 的数据分发，来确保事件源的可追溯。且在 LiveData 的加持下，使事件分发变得生命周期安全。所以这种场景下没 EventBus 更没 Broadcast 什么事儿了。

2.系统广播接收能力的受限。主要还是由于监管不严，导致的流氓 App 监听各种系统广播来自启，开机自启、开 Wi-fi 自启、关 Wi-fi 也自启，就差关机自启了 … 导致后续的 Android 系统被官方狠抓、限制系统广播的滥用。

所以，**Broadcast 不可替代之处，仍然还是 跨进程事件通信**，

**在监听系统事件 或 RemoteView 与 App 本体互通消息 等场景，请想起它**。

## 出师未捷身先死的 WorkManager

WorkManager 问世一年半了，网上多是些东拼西凑、通篇贴代码的文章。

或许就只是简单地从哪里 copy 一份，连代码都没有跑过，就往技术社区发。看到这种不负责任、急功近利的态度，让我感到有被冒犯和不舒服。

前面我们提到了，要想正确理解一门技术，首先就要 **结合背景 从多角度探测它的特质**，通常来说一项技术的存在，多是为了**在特定场景下解决特定问题**，如无法据此穷举到哪怕一个非他不可的理由，那么它便谈不上有被进一步认识和应用到项目开发中的价值。

WorkManager 就是这样一个存在。

首先它并不是跨进程组件，因而 Service 的特质它不具备，也无法替代。Google 设计它的本意，是为了**托管 延迟定时的任务**。也即有了它，哪怕 App 进程被回收、系统重启，**只要该 App 的 TaskRecord 还存在于最近访问列表中**（对这句描述背后的事情性质不理解的话，可回顾[《你丢了 offer，只因拎不清 Activity 任务和返回栈》](https://xiaozhuanlan.com/topic/7812045693)的文末的增量更新），那么 App “生前” 开启过的延迟任务，WorkManager 会一直把关和执行下去。

例如每隔半小时向后台发送一次日志等。

> 但是现如今，在国产 ROM 的背景下，哪怕最近访问列表 “看起来有卡片在”，却不代表 TaskRecord 仍存活（个人猜测 WorkManager 的持续待命与 TaskRecord 有关，熟悉 ROM 开发的小伙伴 感兴趣可以此为切入点 追溯 framework 源码看看）

所以 WorkManager 几乎是 “出师未捷身先死” 的存在，除非做海外 App，否则在大陆市场，WorkManager 几乎没有用武之地，它顶多在 App 运行期间、或 App 做了 “TaskRecord 保活” 的情况下运作，无法在系统重启后自动运转。

> 关于 TaskRecord 保活，可在 App 中 “忽略电池优化”（代码可根据该关键字自行搜索），并且可书面引导国产 ROM 用户 在最近访问列表中 给 TaskRecord 加 “清理锁”。

关于 WorkManager，感兴趣的小伙伴可直接[访问官网](https://developer.android.google.cn/topic/libraries/architecture/workmanager)。

> **便捷访问：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)

## 版权声明

> Copyright © 2019-present KunMinX

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。