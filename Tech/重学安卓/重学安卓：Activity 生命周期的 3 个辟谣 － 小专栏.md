---
created: 2021-10-13
source: https://xiaozhuanlan.com/topic/0213584967
author: 
---

# [重学安卓：Activity 生命周期的 3 个辟谣 － 小专栏](https://xiaozhuanlan.com/topic/0213584967)


> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

## 前言

上一期我们分享了[《重学安卓：Activity 的快乐你不懂》](https://xiaozhuanlan.com/topic/4568971203)，原本只是想给大家一把进阶的钥匙，让大家无痛地对 Activity 的 **存在缘由和职责边界** 先有个感性的认识，继而埋下好奇的种子、推动自己深入地去探究。

没想到，在复盘 “Activity 生命周期” 的过程中，发现网上盛传的关于 Activity 生命周期的几十篇文章中：没有一篇愿意追根溯源、深入地介绍 “进程模式”、以及结合进程模式探究 “生命周期如此设计的依据”，恰恰相反，它们 **多是在堆砌文字、以讹传讹**：

比如，“Activity 在 onStart 时是可见的，只是此时你看不见它 ~ ”，

又如，“当 Activity 处于 onStop 时可能被系统回收” ……

你是不是被这些 似是而非的说法 糊弄了许多年？🤔

> 考虑到未经深度思考的内容，根本不能算作知识、更不可能被人理解、记住和灵活运用。于是经过再三考虑，我便烦着自己再为生命周期写上一篇，并在 GitHub 上开源了《重学安卓知识点测试代码》的项目（不要慌，文末链接已给出）。

所以如果通过本文，你对 进程模式、生命周期 的存在意义 以及彼此间的关系 有了正确的认识，那我的这番功夫就没有白费 ~

## 文章目录一览

-   前言
-   不得不先讲的进程模式
-   **前景模式、可见模式，二者的区别？**
-   Activity 的正常生命周期
-   生命周期节点与进程模式的对应关系？
-   为何存在生命周期的设计？
-   节点的特点、区别，及注意事项？
-   **Note 2020.9.26 加餐：**
    -   分享一个用于代替 “在 onPause 和 onStop 中做耗时操作” 的好招
-   辟谣时间到 ~
-   综上
-   **Note 2020.11.4 加餐：**
    -   面试时切忌使用 “Activity 被系统回收” 等说辞
-   **Note 2021.07.13 加餐：**
    -   可见模式，不如我们称其为 “失焦模式”

## 不得不先讲的进程模式

许多文章会跳过进程模式，直接开始讲生命周期，**导致很多细节都是一笔带过、甚至张冠李戴**。

因此我们先从进程模式开始讲。

如果此前你没有明确过这个概念，那么务必借着这个机会了解一下 ~

### 何谓进程模式？

Android 平台的 App，通常情况下都是单进程。

**由于 Android 平台资源有限，需要为不同进程设置优先级，以便在系统资源紧张的情况下，将优先级较低的进程杀死，以释放资源**。

因而，进程模式的存在就是为了标记和区分进程的优先级。

### 存在哪几种进程模式？

按优先级从高到低，进程模式主要包含：

`前景进程`、`可见进程`、`服务进程`、`背景进程`、`空白进程` 这 5 大类别。

![](https://images.xiaozhuanlan.com/photo/2021/a1e4a82bc9771970300307a37fcd2476.png)

通常，**App 进程的级别，由其活跃的或处于栈顶的组件的活动状况（比如所处生命周期）决定**。

例如，当一个 App 的 Activity 处于 `onResume`，**那么该 Activity 所在的整个进程都会成为前景进程**。

> 划重点 👆 👆 👆

于此同时，需要再次强调的是，**当系统回收资源时，针对的是 App 的进程，而不是针对 App 进程中的某个组件**。（此处对应文末的 “辟谣 2”）

> 划重点 👆 👆 👆

### 前景模式、可见模式，二者的区别？

由于手机屏幕空间有限，一次只能展示一个窗口，但如果你拿 PC 来考虑，就不难理解为何要同时存在 “前景” 和 “可见” 这两种概念。

**前景模式就相当于 PC 中 “获得焦点” 的窗口。**

**可见模式即是那些你可以看见，但 “失去焦点” 的窗口。**

在 Remix OS 等安卓桌面操作系统中，你就会理解这样设计的价值。

> 划重点 👆 👆 👆

![](https://images.xiaozhuanlan.com/photo/2021/8c4709ac3996de272f7c17d03eae32bd.png)

介绍完进程模式，下面我们开始结合 进程模式 来介绍 生命周期。

## Activity 的正常生命周期

Activity 生命周期包含正常流程和重建流程。

考虑到本文的主题是介绍 进程模式和生命周期 的概念及对应关系，加上 重建流程除了流程本身，还涉及到 状态保存和恢复 等知识，因而 重建流程 的内容我们放在未来某个单独的文章来介绍。

### 生命周期的流程与进程模式的关系？

**Activity 生命周期节点**：

`onCreate`，`onStart`，`onResume`，`onPause`，`onStop`，`onDestroy`，`onRestart`。

![](https://images.xiaozhuanlan.com/photo/2021/09f60e6f7b01f858bc4c2fc87a6af5a1.png)

**当 App 处于背景模式时，类似于 PC 上窗口被最小化，随时有可能被系统回收**。

> 划重点 👆 👆 👆

![](https://images.xiaozhuanlan.com/photo/2021/d37d0c4067a16b7021f2702000b940bc.png)

为何设计成先走 `onPause`，等到对方 `onResume` 后再走 `onStop` 呢？

因为处于前景的窗口只能有一个，为了使跳转到的 Activity 能够前景显示，首先得使此前的 Activity 离开前景模式，所以也可以这么说，`onPause` 对于系统的意义就在于离开前景模式，对于开发者的意义就在于离开前景时有机会做一些小操作。

再就是，Activity 跳转的过程 是在同一个线程内 **同步执行** 的，因而 **为了使新页面的内容更快地被呈现**，流程得设计为 先走新页面的 onCreate ~ onResume，再走旧页面的 onStop。

![](https://images.xiaozhuanlan.com/photo/2021/d80245bb6e2df6335c41da3553c4ce80.png)

服务模式不在本主题的范畴中，故不累述。

**空白模式，是指系统为了回收内存，而将处于背景模式的 App 回收成空白模式，等到下一次需要前台展示了，再恢复内容和重新渲染**。（所以不要觉得被回收了就一无所有了，该保留的状态数据，系统还是会保留的，等到需要重新回到前景时，系统会为 App 恢复状态数据，做到 “起死回生”）。

> 划重点 👆 👆 👆

### 为何存在生命周期的设计？

![](https://images.xiaozhuanlan.com/photo/2019/d6fd9dc9d6057826e08b32fd1daae9f9.gif)

早些年我在大学自学 C# Winform 时，主动地就会想到去利用这些生命周期 “窗体事件” 以执行一些轻量级的保存等操作，所以可见这些窗体事件的存在，是因为开发者本来就会有这个需要。

简言之，**生命周期的本质是基于窗体事件的编程，显示模式则对应了或者说绑定了窗体事件的其中几种**。

### 节点的特点、区别，及注意事项？

-   `onCreate` 和 `onDestroy` 只会走一次。`onStart`、`onResume`、`onPause`、`onStop` 可能会因为用户的操作而反复走多次。
-   通常是在 `onCreate` 中 setContentView 和初始化 UI 控件。为何这么做呢？因为 `onStart` 或 `onResume` 都可能重走，比如 `onRestart` 导致的重走 `onStart`，或 `onPause` 导致的重走 `onResume`。如在 `onStart` 或 `onResume` 中初始化视图，就可能导致反复初始化。

> 划重点 👆👆👆

-   此外，在 `onPause` 中尽量别做耗时操作，因为跳转页面时，是先走旧 Activity 的 `onPause` 再走新 Activity 的 `onCreate` -> `onStart` -> `onResume`，这个过程是串行的，因而 `onPause` 耗的时间越长，走到 `onResume` 就越晚，给用户的感觉就是反应迟钝。
-   所以，跳转页面时，有耗时的操作，尽量放在 `onStop` 中做。但也别做过于耗时的操作，因为处于 `onStopped` 节点的页面所对应的 App 进程，有可能会被系统回收（此处特指按 home 键回到桌面后等场景），当内存不足时，那么 `onStop` 中的操作就可能未完成。

## Note 2020.9.26 加餐：

### 分享一个用于代替 “在 onPause 和 onStop 中做耗时操作” 的好招

上述提到的不建议在 onPause 和 onStop 中做耗时操作，主要目的是说明，**“尽可能不要把保存数据的希望全寄托在 onPause 或 onStop 时机”**，并且许多场景的数据其实可以提前缓存的：

例如开发一款笔记软件，那么在新建笔记时，就应先建个临时文档，每隔若干秒从内存中备份一次数据到存储空间，而不是全程都在内存中编辑、直到最后一刻点击保存才新建和存储到持久化空间，不然总会出现意外状况，导致走 onPause、onStop 而且还未能来得及保存 进程就被消灭。

例如 在自动杀后台的国产 ROM 上，笔记写到一半忽然来了个电话，聊完电话再切回去时 发现内容丢失。

## 辟谣时间到 ~

综上：

-   进程模式的存在，是为了区分进程的优先级，以便系统回收优先级低的进程，并将资源留给优先级高的进程。
-   生命周期的存在，是为了让开发者有机会在窗口创建和销毁期间的每一个节点，完成必要的小操作。

**辟谣1**：所谓 “Activity 在 onStart 时是可见的，只是此时你看不见它 ~ ”，正确的说法应是，“**当 App 处于可见模式，对于安卓（桌面）操作系统来说，它就是一个未获取焦点的窗口**”。

**辟谣2**：所谓 “当 Activity 处于 onStop 时可能被系统回收”，事实是，“**当 App 的进程处于背景模式时，可能被系统回收**”。

## Note 2020.11.4 加餐：

### 面试时切忌使用 “Activity 被系统回收” 等说辞

> 系统回收的是进程，系统回收的是进程，系统回收的是进程！
> 
> 重要的事情要讲三遍 👆👆👆
> 
> **请不要再使用 “Activity 被系统回收” 等与客观实际有一定出入的描述**（尤其在面试时，因为此处无意间流露了对 “计算机操作系统” 等基础知识的掌握程度，容易给人留下专业基础不扎实的印象。当然如果你是有意借此试探面试官的反应，看他到底 “行不行”，那就当我没说）
> 
> 具体而言，如果 Activity A 和 B 分属于同一个 App 的两个进程，且 A 在后台进程，那么内存不足时 A 可能因为进程被回收而 **受牵连**；而如果 A 和 B 在同一个进程内，且 B 乃至 B 所处的进程处于前景或可见，那 A 则不会 受牵连。
> 
> 简言之，**这类事情的本质是 “进程被系统回收”**。也即，只要 Activity 是保持在 Stop 而未步入 Destroy（例如处于非栈顶的位置），那么该 Activity 此时 “被回收” **只可能是因为所在进程被系统回收**。
> 
> 划重点 👆👆👆

**辟谣3**：所谓 “onStart、onStop 和 onResume、onPause 的区别是可见模式与前景模式的区别”，事实是，“**当从 onResume 前往至 onPause 时，或当从 onStop 跳回至 onStart 时，此时的 onPause 或 onStart 才是可见模式。前景模式当且仅当 onResume，而 Activity onStop 时，若此时 App 中没有运行其他 Activity 或前台服务等组件，那么 App 早已遁入背景模式，并不存在 onStop 时 App 进程处于可见模式的情况**”。

> 全文完

## Note 2021.07.13 加餐：

### 可见模式，不如我们称其为 “失焦模式”

为保持称谓的一致，本文在正文中沿用了 “官方文档” 对其所定义的各进程模式的称谓，同时本文也另辟蹊径地通过 “类比” 的方式来分析 “前景”、“可见” 等模式的本质和设计依据。

为此有小伙伴在理解了本文思路后，因官方 “可见模式” 这个概念的语义而产生困扰，毕竟确实如其所说，**从字面上看，“可见” 即包含了 “前景可见” 和 “被部分遮挡但可见” 这两种情况**，

> 其实我个人猜测，所谓 “前景模式” 和 “可见模式” 的概念，大概率是继承于 PC 操作系统中窗体的相关概念，然而 Android 又不想和它重名，就像鸿蒙手机系统的 Framework “换汤不换药” 地将 Activity 等组件改名为 Ability 一样，

因而综上，我们不妨结合本文的思路，来给 “可见模式” 取个更为恰当的名称 —— “失焦模式” —— **失去焦点的模式**，与之相对的就是 “获焦模式”，这样无论从哪个角度来看，都是恰当的，毕竟 **获焦或失焦隐含的潜台词就是 “页面已经可见了”**。

![](https://images.xiaozhuanlan.com/photo/2021/53845473ddc00ba27df9e46511476ed0.png)

> **便捷访问：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)
> 
> **视图控制器系列：**
> 
> [重学安卓：Activity 生命周期的 3 个辟谣](https://xiaozhuanlan.com/topic/0213584967)
> 
> [重学安卓：绝不丢失状态的 Activity 重建机制](https://xiaozhuanlan.com/topic/7692814530)
> 
> [重学安卓：你丢了 offer，只因拎不清 Activity 任务和返回栈](https://xiaozhuanlan.com/topic/7812045693)
> 
> [重学安卓：Intent 好比你的择偶标准](https://xiaozhuanlan.com/topic/2869301475)
> 
> [重学安卓：我的碎片很听话，你的 Fragment 有自己的想法](https://xiaozhuanlan.com/topic/0937256481)

## 版权声明

> Copyright © 2019-present KunMinX

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。

