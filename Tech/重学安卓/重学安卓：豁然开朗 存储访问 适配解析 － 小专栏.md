---
created: 2021-10-13
source: https://xiaozhuanlan.com/topic/5240638917
author: 
---

# [重学安卓：豁然开朗 存储访问 适配解析 － 小专栏](https://xiaozhuanlan.com/topic/5240638917)


> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

### 前言

近来偶尔在群里看到有读者提到，“分区存储” 的适配没有头绪，不知道从哪里开始学。

是网上介绍 “分区存储适配” 的资料太少吗？不是的，恰恰相反，在 2019 年 Android 官方释放 “分区存储适配” 的消息后，网上与之相关的信息铺天盖地，

然而它们无一例外都是假定 开发者事先已对 “所有与之相关的 **前置知识**” 都有了全面的铺垫，加之有不少开发者之前是专注于 后端、嵌入式 等领域 而 **鲜少有移动端的场景来接触和反思**，

### 被开发者一拖再拖的分区存储适配

这也就导致了，有不少新上手的小伙伴 始终未能理解 “**存储访问及其适配**” 的本质 —— 每当提起 “适配” 的时候，毫无头绪，**不知道为什么要学**，只是被 Android 11 逼的（听说要强制适配呢），

> 于是心里就犯怵、犯嘀咕 —— 这东西究竟值不值得我去了解呢？存储访问 **有什么好学的呢**？适配又是 **干什么多此一举呢**？我究竟是该花 5 分钟学习 还是 15 分钟学习呢？于是，日复一日，年复一年，未曾了解 **事由和来龙去脉** 的开发者，就这么一路从 Android 10 苟到了 Android 11 正式版 …

所以这一期，我们基于深度思考的原则，**从实际的角度出发** 为小伙伴们铺垫 “存储访问及其适配” 的前置知识，如果看完这篇 你发觉 “原来存储访问是这么回事啊！原来适配是出于这个原因啊！原来 **存储访问的地位** 如此核心啊！原来适配的每一步都有与之相对应的考虑啊！”，那我的愿望也就达到了。

### 文章目录一览

-   前言
-   被开发者一拖再拖的分区存储适配
-   存储访问及其适配 究竟什么来路
-   为什么要有存储访问
    -   这 “收” 和 “发” 的过程中究竟经历了哪些细节？
    -   为什么要大动周折安排这些过程呢？
    -   **1.从 “效率和平衡” 的角度理解**
    -   **2.从 “复用和隐私” 的角度理解**
-   所以为什么要适配存储访问
    -   当我们提起适配的时候，我们是在说什么
    -   是出于什么考虑强制我们适配
-   **FileProvider 的存在缘由和适配**
    -   FileProvider 适配前的混沌世界
    -   FileProvider 是如何解决这个问题的
-   **分区存储 的存在缘由和适配**
    -   分区存储 适配前的混沌世界
    -   分区存储 是如何解决这个问题的
-   **Note 2020.12.21 加餐：**
    -   从 Android 10 起，MediaStore 有 2 个坑需要注意
-   **Note 2020.12.23 加餐：**
    -   适用于团队开发的、记忆成本较低的 “分区存储” 统一适配参考建议
-   综上

### 存储访问及其适配 究竟什么来路

按照惯例，开门见山，先说结论：

> “存储访问” 主要是从 “**效率和复用**” 的角度出发，透过 **缓存** 来提升访问效率、降低服务器负担，透过 持久化存储 来实现媒体数据的复用。
> 
> 在所有的 “数据交互” 活动中，存储访问是极其高频的存在，任何 “移动互联网客户端” 的操作都离不开它，是起到 **承上启下** 的作用。
> 
> “存储访问适配” 主要是从 “**保护用户隐私**” 的角度出发，透过新的传输机制，来确保本 App 的私密空间信息不被越界访问和泄漏。
> 
> 存储访问体系在历史上曾有过多次局部的更新，我们 **所谓的适配，多是去适配这些 “从隐私安全角度出发” 的局部新设计**。

如果这样说还不理解的话，那么下面我将逐个对上述结论的背景进行解析，方便小伙伴们奠定感性的认识。

### 为什么要有存储访问

要思考这个问题，其实很简单。回溯一下你每天的互联网生活：

手机的存在无非就是 “收发数据” 的工具，通过它，你可以接收和查阅身边人以及世界范围内的动态和信息（通过微信朋友圈、抖音、浏览器等等），与此同时你也可以编辑和发送关于你自己的动态。

朋友圈场景示例

抖音场景示例

![](https://images.xiaozhuanlan.com/photo/2020/dabc19df22122907c49e1feb8878890e.jpg)

![](https://images.xiaozhuanlan.com/photo/2020/f37efd3cfcdf4151b8b7dafe511934e0.jpg)

#### 这 “收” 和 “发” 的过程中究竟经历了哪些细节呢？

以 “收” 为例，这中间主要经历了：

> 1.向服务端发起请求，
> 
> 2.收到响应结果，展示到界面（数据在 “内存 RAM” 中），并 **缓存一份数据到私有目录**（数据被持久化存储到 “闪存 ROM” 中），

以 “发” 为例，这中间主要经历了：

> 1.在内存中编辑数据，点击按钮提交，
> 
> 2.提交时，会先展示结果到界面、并且 **缓存一份数据到私有目录**，同时再提交给服务端，

#### 为什么要大动周折安排这些过程呢？

明明只是 “网络请求和内存” 就可以搞定的事，为何还要加个缓存、乃至涉及到 “本地存储访问” 呢？

#### 1.从 “效率和平衡” 的角度理解

> “缓存” 的存在，是出于效率的考虑：

**1.1.对手机来说**，有了缓存，下次再加载上次访问过的内容时，可以直接从本地调取，而无需重新下载，这大大节省了 **时间、流量、电量**：

毕竟，一个页面通常包含数十张图片，每个图片都对应着一个 https 请求，且网络通常存在几十毫秒的延迟，与此同时，本地闪存 ROM 的读写速度最低却也在 300MB/s 以上，因而每次都重新请求图片的耗时远大于从缓存读取。

![图片来自网络。图为 Android 闪存速度的发展](https://images.xiaozhuanlan.com/photo/2020/fcdba807e564c0ed20899e1d0e3996f3.jpg)

图片来自网络。图为 Android 闪存速度的发展

并且 https 请求涉及加解密运算，大量的 https 请求就意味着大量的加解密运算，在耗费运算资源的同时，也将流失大量电量，要是用户在监测工具中看到有个 App 如此耗电，多半是会直接卸载的。

> 划重点 👆 👆 👆

**1.2.对服务端来说**，客户端缓存的存在，使得服务端的 “超高并发” 有所减缓，从而大幅降低网络拥堵和服务器崩溃的概率。

这个 “超高并发” 到底有多高呢？以下通过一组数据来方便你建立感性的认识：

根据[《中国互联网络发展状况统计报告》](http://www.cac.gov.cn/2020-04/27/c_1589535470378587.htm)的数据，截至 2019 年底，移动互联网接入的流量已由 7 年前的 12.7 亿 GB 翻了 100 倍（2020 年更不用说）

![图片截取自上述报告，图为移动端流量的增长概况](https://images.xiaozhuanlan.com/photo/2020/769e5bda0afda93604a558f6db900073.jpg)

图片截取自上述报告，图为移动端流量的增长概况

所以就是这样一个疯狂爆发的背景，使得客户端务必加个 “缓存” 来缓一缓。

#### 2.从 “复用和隐私” 的角度理解

存储访问，除了缓存，还有个作用就是复用，例如你在朋友圈或任一社区看到好看的图片、表情，想要保存下来，以便未来作为素材编辑和发送，

与此同时，存储访问在数十年前就存在了 “公私分明” 的设计，也即为每个 App 提供私有的目录，让别的 App 通常情况下无法访问：

一方面是出于防止私有信息泄露，另一方面是为了让相册等公共领域的素材保持干净，毕竟你不想在相册里看到 除你主动保存之外的图片素材对吧。

### 所以为什么要适配存储访问

#### 当我们提起适配的时候，我们是在说什么

在思考 “为什么要适配存储访问” 之前，我们先来确认一下，当我们提起适配的时候，我们到底是在说什么 —— 为什么是 “适配”，为什么不是 “改进” 或 “升级” 呢？

> 因为这是一种 **历史包袱**：适配涉及的是 对已停止维护的老系统的 **兼容**，以及对新系统新设计的 API 的 **支持**。

也即我们经常在代码中看到的：

![](https://images.xiaozhuanlan.com/photo/2021/0f78d997650b07f17cc8ee0d33d8828a.png)

#### 是出于什么考虑强制我们适配

适配通常是出于 **隐私安全、硬件匹配** 等因素的考虑。硬件匹配，比如这些年 Android 的 “刘海屏状态栏、折叠屏页面重建、全面屏手势” 等等；

存储访问的适配 主要涉及的是 隐私安全。

也许在国内有不少开发者 首先对自己的隐私就不关心，乃至很少具备这方面的意识，而这也就导致了 迟迟没能理解和重视 对存储访问的适配。

> 例如尽管是个看似普通的文件传输场景，然而如果潜伏在后台的 App 包含恶意代码、可借机从你 App 的隐私空间中顺走身份证、手机号、银行卡等隐私信息，从而盗刷机主的网银账户呢？

那么接下来 我们由远到近地介绍 历史上有过的存储访问适配。

### FileProvider 的存在缘由和适配

#### FileProvider 适配前的混沌世界

FileProvider 实际上是 Android 4.4 时期就存在的设计，它被强制适配是发生在 Android 7.0 系统。

关于 FileProvider，[官方文档](https://developer.android.google.cn/reference/androidx/core/content/FileProvider) 有过这样一段描述：

> “每当别的 App 透过 File Uri 来访问你 App 的私有文件时，为了达成访问，需要从底层文件系统将访问权限开放，并且直到权限被收回前，其他任意 App 都是可以访问的。”

怎么理解这段话的含义呢？

上述描述中没有提及权限被收回的时机，因而隐含的关键信息是 “**时机不可控 和 作用域不受限**”，也即，**当下虽然只是你 AppA 和 AppB 之间的文件传输，但这文件传输的达成，需要从底层文件系统更改权限**，

这就好比，你和朋友约好下午 3 点来你家玩，本来你只须到点开个小窗守着朋友的到来，可你却把自家 前门 后门 左门 右门 统统打开了，这让路过的小偷得以 趁虚而入、盗走他想要的东西。

#### FileProvider 是如何解决这个问题的

很简单，既然 **通过 File Uri 访问，涉及底层文件系统访问权限的修改**，那改用别的方式就是了 —— 通过 content Uri 访问。

这是一种源于 Web 开发的 “**虚拟目录映射**” 的设计，通过 content Uri，系统会自动呈现实际路径中的内容，就和你直接通过实际路径访问到的结果是一样的，唯一的区别就在于，使用 content Uri 无需开启 “底层文件系统权限”，且 FileProvider 在此基础上增加了“只需授予 **运行时级别** 临时权限”的设计，如此你俩在传输文件时，潜伏的 App 无法趁虚而入，且 **在对方与传输相关的 Activity 离开栈顶或 Service 停止运行后，权限便及时作废**。

> 划重点 👆 👆 👆
> 
> 提示：运行时权限的特质是，只针对被授予的进程，而非对所有进程无差别开放

当然，既然是 “虚拟目录映射”，那自然需要先配置一下虚拟目录映射了，不然怎么知道哪个 content 到底对应着哪个 file 目录，于是也就有了 **FileProvider 适配三步骤**：

**1.在 AndroidManifest 中声明 FileProvider**，

因为它毕竟也是个组件，是 contentProvider 的子类。并且注意其中配置了 grantUriPermissions 为 true，用于运行时获取 Uri 临时访问权限。

![](https://images.xiaozhuanlan.com/photo/2021/256a2608e3bebc9d6405c4dd5e3005eb.png)

**2.定义 content 虚拟目录映射**，

比如 `Context.getExternalFilesDirs()`、`getExternalCacheDir()` 或任一你允许其他 App 运行时访问的目录（根目录目前主要定义有 7 种，具体可参考 [Specifying Available Files](https://developer.android.google.cn/reference/androidx/core/content/FileProvider#SpecifyFiles) 一节的罗列）。

![](https://images.xiaozhuanlan.com/photo/2021/0e859cb5110c34d07e8645b45735c226.png)

**3.动态获取 content uri**，这个通过 `FileProvider.getUriForFile()` 即可将 file Uri 转换为传输时所需的 content Uri。

得到的结果比如：

```
content:
```

前面 `com.kunminx.fileprovider` 对应的是 manifest 中定义的 authorities，中间 `external_files/kunminx/photo` 分别是 file\_path 中定义的 name 和 path，最后就是文件名本身。

**最后是对传输文件方法的适配：**

![](https://images.xiaozhuanlan.com/photo/2021/0528d8b5e7933e263dc4a5caff4edde6.png)

> 这样梳理了一遍，关于 “**为什么适配 FileProvider**”、以及 “**FileProvider 适配为什么要做这些工作**”，是不是也都容易理解了呢？

### 分区存储 的存在缘由和适配

#### 分区存储 适配前的混沌世界

分区存储并不是什么新鲜的设计，而是 “本应如此” 的设计。

在谈论分区存储之前，我们先来回溯一下，上文提及的关于 存储访问的两大类作用：为了 “**效率和平衡**”、“**复用和隐私**” 而存在，因而存储访问从一开始就被设计为，包含 **私有目录和公有目录**。

私有目录 是专用于存放 App 私有的 **缓存、配置、私密信息** 等等；

公有目录 是用于存放那些可复用的媒体文件，例如 **图片表情** 等等。

> 出于节省存储空间的考虑，**当 App 被卸载时，私有目录也随即被清空**，以便自动将缓存清理。因而 那些需要复用的文件 可存放在公有目录。
> 
> 划重点 👆 👆 👆

并且考虑到缓存大文件的需要，因而 **私有目录在 “内部空间 和 外部空间” 各有分布**，而大文件缓存就主要存储在 空间相对充裕的外部空间：

![](https://images.xiaozhuanlan.com/photo/2021/56d492ab5095eca14fad3bb58a1de4c0.png)

> **Tip：外部空间 除了私有目录外的区域 都是公有目录**

这种 “公私分明” 的设计还有什么好处呢？有的，

例如用户打开相册时，通常能 **瞬间载入**、并且只呈现公有目录下 **用户主动保存的图片**，而更少地会将缓存图片也展示出来，之所以可以做到这一点，是因为 相册中的记录都是 **源于 MediaStore（媒体库）的相关组件 事先对公有目录的扫描**，并且扫描过程中会主动跳过私有目录。

> 划重点 👆 👆 👆

但是，总是会存在一些 App 开发者，对私有目录毫无概念，随意在公有目录保存缓存的图片，使你打开相册 映入眼帘的就是些 “不知道什么时候被下载下来的” 乱七八糟的图片。

![如图，缓存广告图片被显示在相册中](https://images.xiaozhuanlan.com/photo/2021/6fe94ad2f835a1799bdb25ab90c2e477.png)

如图，缓存广告图片被显示在相册中

> **分区存储应运而生**

#### 分区存储 是如何解决这个问题的

在分区存储的强制规范下，媒体文件要存放到公有目录，就必须直接或间接地使用 MediaStore 的 API 来手动 “**备案**” 到媒体库，这样要求带来什么好处呢？

> 首先，它**强制要求备案时填写 “相对路径”**（见下文 MediaStore 的代码），**且相对路径的根节点 务必是 “公有目录默认媒体目录分类” 的其中一个**，例如 “Picture、DCIM、Music、Video、Document、Download” 等等，
> 
> 其次，**在 Android 11 及以后的系统中，就算申请了外部空间读写权限，直接通过 File Uri 来读写也会抛出异常**。

为什么要这样设计呢？为的是阻止那些 “不遵守规则的开发者” 透过 File Uri 在外部空间随处新建文件夹，而**只能基于 content Uri 在指定目录的 “虚拟目录映射” 下创建子目录和读写媒体内容**，

因而这些开发者等于是 **被迫遵循了规范**：要么是老老实实地在私有目录下存储缓存，要么是万不得已需要存储可复用媒体文件时，才大费周折地在默认媒体目录下建一个自己 App 的子目录来存储，而不至于眼花缭乱弄的满地都是。

![如图，Android 9 外部空间被随处新建的各种缓存文件夹](https://images.xiaozhuanlan.com/photo/2021/f476e5104c681cf947ab35c573c3fc7e.png)

如图，Android 9 外部空间被随处新建的各种缓存文件夹

归根结底，**分区存储的重要目标之一就是 “还用户一个干净的公有目录”**。

> 划重点 👆 👆 👆

具体而言：

1.访问本 App “外部空间的私有目录” 时，可直接透过上文罗列的 `Context.getExternalFilesDirs()` 等方法进行访问，无需申请运行时权限

> 这个设定其实一直以来都成立，只不过多数人完全不知情，一来他们 **从未反思过 也不清楚 “外部空间私有目录” 的存在**，二来他们只知道 “只要是外部空间就去使用 `Environment.getExternalStorageDirectory()`，而该方法的使用就不得不在 manifest 中配置 **外置存储访问的读写权限**”。
> 
> 划重点 👆 👆 👆 👆 👆

2.访问本 App “外部空间的公有媒体文件” 时，可透过 MediaStore 来访问，且 **同样无需申请访问权限**。唯有透过 MediaStore 访问其他 App 的 “外部空间的公有媒体文件” 时，需要申请权限。（该设定适用于 Android 10 及后来的系统。）

> 划重点 👆 👆 👆
> 
> 从 Android 10 起，MediaStore 有 2 个坑需要注意，详见文末 Note 2020.12.21 加餐。

![](https://images.xiaozhuanlan.com/photo/2021/57aa2bfbe17f924bcc26059841bb0f6d.png)

3.通过 SAF（全称 Storage Access Framework，存储访问框架）**无需权限即可访问自己或其他 App 的公有媒体文件**（SAF 是 Android 4.4 就存在的设计，只不过，SAF 的用户体验一言难尽，例如一次只能选一张图片、每次都是从根目录访问、Android 11 SAF 让人摸不着头脑的交互等等 … ）

![SAF](https://images.xiaozhuanlan.com/photo/2021/60dd234dfa374e7d144e0590f64a0d70.png)

SAF

![](https://images.xiaozhuanlan.com/photo/2021/ac8b6c5aaacff58a16d9e5711902343c.png)

简言之，在 Android 11 下：

![](https://images.xiaozhuanlan.com/photo/2021/d7d9a9a1a0af5daf7e57ec857abd8e41.png)

> 这样梳理了一遍，关于 “**为什么适配分区存储**”、“**分区存储的适配为什么要做这些工作**”、“**具体都有哪些场景、且各场景下有哪些方式可应对**”，是不是也都容易理解了呢？

### 综上

“存储访问” 主要是从 “**效率和复用**” 的角度出发，透过 **缓存** 来提升访问效率、降低服务器负担，透过 持久化存储 来实现媒体数据的复用。

> 在所有的 “数据交互” 活动中，存储访问是极其高频的存在，任何 “移动互联网客户端” 的操作都离不开它，是起到 **承上启下** 的作用。

“存储访问适配” 主要是从 “**保护用户隐私**” 的角度出发，透过新的传输机制，来确保本 App 的私密空间信息不被越界访问和泄漏。

> 存储访问体系在历史上曾有过多次局部的更新，我们 **所谓的适配，多是去适配这些 “从隐私安全角度出发” 的局部新设计**。

当我们在说适配的时候，我们实际是在兼容旧系统设计的同时，在新系统下遵循新设计。

当我们在适配 FileProvider 时，我们实际上是透过 **App 指定目录的 “虚拟目录映射” + 时机可控 且作用域有限的 “运行时权限”**，来替代 7.0 之前系统采用的 “底层文件系统读写权限无差别开放” 的不安全设计。

当我们在适配 分区存储时，我们实际上是被迫遵循强制规范：通过被迫只在 **系统指定的默认媒体根目录的 “虚拟目录映射”** 下创建子目录，来还用户一个清朗的外部存储空间。

这样说，你理解了吗？

### Note 2020.12.21 加餐：

#### 从 Android 10 起，MediaStore 有 2 个坑需要注意

1.从 Android 10 起，MediaStore 方式访问自己 App 公有数据时，支持全类型的数据；

而当访问别的 App 的公有数据时，MediaStore 方式仅可通过 Images、Audio、Video 这三种 Uri（例如 `MediaStore.Images.Media.EXTERNAL_CONTENT_URI`）访问媒体文件，Downloads 目录下的文档（例如 \*.txt 等）则是只可通过 SAF 读写。

2.从 Android 10 起，MediaStore 在插入新的媒体记录时，会自动添加当前 App 包名到 `MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME` 字段，并且后续访问时，也是根据该字段的值，来判断数据是否属于当前 App（从而决定是否需要权限才可访问）。

而当自己 App 卸载后，自己 App 的公有数据将失去 `OWNER_PACKAGE_NAME` 的值，从而沦为 “无主的数据”，此时通过 MediaStore 方式访问，就像 “访问其他 App 的数据” 一样需要申请权限。

对此姑且认为是个 “反人类” 的设计，因为符合用户预期的做法时，App 卸载并重装后，之前创建的公共数据 “还在”。

### Note 2020.12.27 加餐：

#### 适用于团队开发的、记忆成本较低的 “分区存储” 统一适配参考建议

现实中，我们往往是以 “多人协作的团队开发” 为背景开展工作的，每个人都有各自专注的领域，乃至难以确保 每个成员都对各个细节的认知做到面面俱到，

因而有必要探索一种在 **学习成本、记忆成本、研发成本** 上取得平衡的适配方案。

所以这里分享一则较小适配成本的参考建议：

1.结合上文的分析，我们已知，在访问 “本 App 在内外空间的私有目录” 时，可通过 Context 方式无需权限地访问，这个操作从 Android 4.4 起往后都是一致的。

2.对于外部空间的公有目录的读写，从 Android 4.4 起到往后都可通过 SAF 来完成，无需申请权限。

SAF 的缺点是 界面单调、操作不便、不可定制交互，因而如果 App 十分重视统一的 UI 风格，那么从 Android 4.4 到 Android 10，我们可以统一通过 `Environment.getExternalStorageDirectory()` 以 File Api 的方式读写（需要申请权限），而只有 Android 11 起才使用 MediaStore 等方式。

注意此时 Android 10 须通过在 manifest 的 Application 节点添加 `requestLegacyExternalStorage = true` 来声明对 File Api 方式的兼容。

简言之就是：

![](https://images.xiaozhuanlan.com/photo/2021/16b6d1e31f91308951a2122ccd885816.png)

> **快捷访问：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)

### 版权声明

> Copyright © 2019-present KunMinX

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。

> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

### 前言

近来偶尔在群里看到有读者提到，“分区存储” 的适配没有头绪，不知道从哪里开始学。

是网上介绍 “分区存储适配” 的资料太少吗？不是的，恰恰相反，在 2019 年 Android 官方释放 “分区存储适配” 的消息后，网上与之相关的信息铺天盖地，

然而它们无一例外都是假定 开发者事先已对 “所有与之相关的 **前置知识**” 都有了全面的铺垫，加之有不少开发者之前是专注于 后端、嵌入式 等领域 而 **鲜少有移动端的场景来接触和反思**，

### 被开发者一拖再拖的分区存储适配

这也就导致了，有不少新上手的小伙伴 始终未能理解 “**存储访问及其适配**” 的本质 —— 每当提起 “适配” 的时候，毫无头绪，**不知道为什么要学**，只是被 Android 11 逼的（听说要强制适配呢），

> 于是心里就犯怵、犯嘀咕 —— 这东西究竟值不值得我去了解呢？存储访问 **有什么好学的呢**？适配又是 **干什么多此一举呢**？我究竟是该花 5 分钟学习 还是 15 分钟学习呢？于是，日复一日，年复一年，未曾了解 **事由和来龙去脉** 的开发者，就这么一路从 Android 10 苟到了 Android 11 正式版 …

所以这一期，我们基于深度思考的原则，**从实际的角度出发** 为小伙伴们铺垫 “存储访问及其适配” 的前置知识，如果看完这篇 你发觉 “原来存储访问是这么回事啊！原来适配是出于这个原因啊！原来 **存储访问的地位** 如此核心啊！原来适配的每一步都有与之相对应的考虑啊！”，那我的愿望也就达到了。

### 文章目录一览

-   前言
-   被开发者一拖再拖的分区存储适配
-   存储访问及其适配 究竟什么来路
-   为什么要有存储访问
    -   这 “收” 和 “发” 的过程中究竟经历了哪些细节？
    -   为什么要大动周折安排这些过程呢？
    -   **1.从 “效率和平衡” 的角度理解**
    -   **2.从 “复用和隐私” 的角度理解**
-   所以为什么要适配存储访问
    -   当我们提起适配的时候，我们是在说什么
    -   是出于什么考虑强制我们适配
-   **FileProvider 的存在缘由和适配**
    -   FileProvider 适配前的混沌世界
    -   FileProvider 是如何解决这个问题的
-   **分区存储 的存在缘由和适配**
    -   分区存储 适配前的混沌世界
    -   分区存储 是如何解决这个问题的
-   **Note 2020.12.21 加餐：**
    -   从 Android 10 起，MediaStore 有 2 个坑需要注意
-   **Note 2020.12.23 加餐：**
    -   适用于团队开发的、记忆成本较低的 “分区存储” 统一适配参考建议
-   综上

### 存储访问及其适配 究竟什么来路

按照惯例，开门见山，先说结论：

> “存储访问” 主要是从 “**效率和复用**” 的角度出发，透过 **缓存** 来提升访问效率、降低服务器负担，透过 持久化存储 来实现媒体数据的复用。
> 
> 在所有的 “数据交互” 活动中，存储访问是极其高频的存在，任何 “移动互联网客户端” 的操作都离不开它，是起到 **承上启下** 的作用。
> 
> “存储访问适配” 主要是从 “**保护用户隐私**” 的角度出发，透过新的传输机制，来确保本 App 的私密空间信息不被越界访问和泄漏。
> 
> 存储访问体系在历史上曾有过多次局部的更新，我们 **所谓的适配，多是去适配这些 “从隐私安全角度出发” 的局部新设计**。

如果这样说还不理解的话，那么下面我将逐个对上述结论的背景进行解析，方便小伙伴们奠定感性的认识。

### 为什么要有存储访问

要思考这个问题，其实很简单。回溯一下你每天的互联网生活：

手机的存在无非就是 “收发数据” 的工具，通过它，你可以接收和查阅身边人以及世界范围内的动态和信息（通过微信朋友圈、抖音、浏览器等等），与此同时你也可以编辑和发送关于你自己的动态。

朋友圈场景示例

抖音场景示例

![](https://images.xiaozhuanlan.com/photo/2020/dabc19df22122907c49e1feb8878890e.jpg)

![](https://images.xiaozhuanlan.com/photo/2020/f37efd3cfcdf4151b8b7dafe511934e0.jpg)

#### 这 “收” 和 “发” 的过程中究竟经历了哪些细节呢？

以 “收” 为例，这中间主要经历了：

> 1.向服务端发起请求，
> 
> 2.收到响应结果，展示到界面（数据在 “内存 RAM” 中），并 **缓存一份数据到私有目录**（数据被持久化存储到 “闪存 ROM” 中），

以 “发” 为例，这中间主要经历了：

> 1.在内存中编辑数据，点击按钮提交，
> 
> 2.提交时，会先展示结果到界面、并且 **缓存一份数据到私有目录**，同时再提交给服务端，

#### 为什么要大动周折安排这些过程呢？

明明只是 “网络请求和内存” 就可以搞定的事，为何还要加个缓存、乃至涉及到 “本地存储访问” 呢？

#### 1.从 “效率和平衡” 的角度理解

> “缓存” 的存在，是出于效率的考虑：

**1.1.对手机来说**，有了缓存，下次再加载上次访问过的内容时，可以直接从本地调取，而无需重新下载，这大大节省了 **时间、流量、电量**：

毕竟，一个页面通常包含数十张图片，每个图片都对应着一个 https 请求，且网络通常存在几十毫秒的延迟，与此同时，本地闪存 ROM 的读写速度最低却也在 300MB/s 以上，因而每次都重新请求图片的耗时远大于从缓存读取。

![图片来自网络。图为 Android 闪存速度的发展](https://images.xiaozhuanlan.com/photo/2020/fcdba807e564c0ed20899e1d0e3996f3.jpg)

图片来自网络。图为 Android 闪存速度的发展

并且 https 请求涉及加解密运算，大量的 https 请求就意味着大量的加解密运算，在耗费运算资源的同时，也将流失大量电量，要是用户在监测工具中看到有个 App 如此耗电，多半是会直接卸载的。

> 划重点 👆 👆 👆

**1.2.对服务端来说**，客户端缓存的存在，使得服务端的 “超高并发” 有所减缓，从而大幅降低网络拥堵和服务器崩溃的概率。

这个 “超高并发” 到底有多高呢？以下通过一组数据来方便你建立感性的认识：

根据[《中国互联网络发展状况统计报告》](http://www.cac.gov.cn/2020-04/27/c_1589535470378587.htm)的数据，截至 2019 年底，移动互联网接入的流量已由 7 年前的 12.7 亿 GB 翻了 100 倍（2020 年更不用说）

![图片截取自上述报告，图为移动端流量的增长概况](https://images.xiaozhuanlan.com/photo/2020/769e5bda0afda93604a558f6db900073.jpg)

图片截取自上述报告，图为移动端流量的增长概况

所以就是这样一个疯狂爆发的背景，使得客户端务必加个 “缓存” 来缓一缓。

#### 2.从 “复用和隐私” 的角度理解

存储访问，除了缓存，还有个作用就是复用，例如你在朋友圈或任一社区看到好看的图片、表情，想要保存下来，以便未来作为素材编辑和发送，

与此同时，存储访问在数十年前就存在了 “公私分明” 的设计，也即为每个 App 提供私有的目录，让别的 App 通常情况下无法访问：

一方面是出于防止私有信息泄露，另一方面是为了让相册等公共领域的素材保持干净，毕竟你不想在相册里看到 除你主动保存之外的图片素材对吧。

### 所以为什么要适配存储访问

#### 当我们提起适配的时候，我们是在说什么

在思考 “为什么要适配存储访问” 之前，我们先来确认一下，当我们提起适配的时候，我们到底是在说什么 —— 为什么是 “适配”，为什么不是 “改进” 或 “升级” 呢？

> 因为这是一种 **历史包袱**：适配涉及的是 对已停止维护的老系统的 **兼容**，以及对新系统新设计的 API 的 **支持**。

也即我们经常在代码中看到的：

![](https://images.xiaozhuanlan.com/photo/2021/0f78d997650b07f17cc8ee0d33d8828a.png)

#### 是出于什么考虑强制我们适配

适配通常是出于 **隐私安全、硬件匹配** 等因素的考虑。硬件匹配，比如这些年 Android 的 “刘海屏状态栏、折叠屏页面重建、全面屏手势” 等等；

存储访问的适配 主要涉及的是 隐私安全。

也许在国内有不少开发者 首先对自己的隐私就不关心，乃至很少具备这方面的意识，而这也就导致了 迟迟没能理解和重视 对存储访问的适配。

> 例如尽管是个看似普通的文件传输场景，然而如果潜伏在后台的 App 包含恶意代码、可借机从你 App 的隐私空间中顺走身份证、手机号、银行卡等隐私信息，从而盗刷机主的网银账户呢？

那么接下来 我们由远到近地介绍 历史上有过的存储访问适配。

### FileProvider 的存在缘由和适配

#### FileProvider 适配前的混沌世界

FileProvider 实际上是 Android 4.4 时期就存在的设计，它被强制适配是发生在 Android 7.0 系统。

关于 FileProvider，[官方文档](https://developer.android.google.cn/reference/androidx/core/content/FileProvider) 有过这样一段描述：

> “每当别的 App 透过 File Uri 来访问你 App 的私有文件时，为了达成访问，需要从底层文件系统将访问权限开放，并且直到权限被收回前，其他任意 App 都是可以访问的。”

怎么理解这段话的含义呢？

上述描述中没有提及权限被收回的时机，因而隐含的关键信息是 “**时机不可控 和 作用域不受限**”，也即，**当下虽然只是你 AppA 和 AppB 之间的文件传输，但这文件传输的达成，需要从底层文件系统更改权限**，

这就好比，你和朋友约好下午 3 点来你家玩，本来你只须到点开个小窗守着朋友的到来，可你却把自家 前门 后门 左门 右门 统统打开了，这让路过的小偷得以 趁虚而入、盗走他想要的东西。

#### FileProvider 是如何解决这个问题的

很简单，既然 **通过 File Uri 访问，涉及底层文件系统访问权限的修改**，那改用别的方式就是了 —— 通过 content Uri 访问。

这是一种源于 Web 开发的 “**虚拟目录映射**” 的设计，通过 content Uri，系统会自动呈现实际路径中的内容，就和你直接通过实际路径访问到的结果是一样的，唯一的区别就在于，使用 content Uri 无需开启 “底层文件系统权限”，且 FileProvider 在此基础上增加了“只需授予 **运行时级别** 临时权限”的设计，如此你俩在传输文件时，潜伏的 App 无法趁虚而入，且 **在对方与传输相关的 Activity 离开栈顶或 Service 停止运行后，权限便及时作废**。

> 划重点 👆 👆 👆
> 
> 提示：运行时权限的特质是，只针对被授予的进程，而非对所有进程无差别开放

当然，既然是 “虚拟目录映射”，那自然需要先配置一下虚拟目录映射了，不然怎么知道哪个 content 到底对应着哪个 file 目录，于是也就有了 **FileProvider 适配三步骤**：

**1.在 AndroidManifest 中声明 FileProvider**，

因为它毕竟也是个组件，是 contentProvider 的子类。并且注意其中配置了 grantUriPermissions 为 true，用于运行时获取 Uri 临时访问权限。

![](https://images.xiaozhuanlan.com/photo/2021/256a2608e3bebc9d6405c4dd5e3005eb.png)

**2.定义 content 虚拟目录映射**，

比如 `Context.getExternalFilesDirs()`、`getExternalCacheDir()` 或任一你允许其他 App 运行时访问的目录（根目录目前主要定义有 7 种，具体可参考 [Specifying Available Files](https://developer.android.google.cn/reference/androidx/core/content/FileProvider#SpecifyFiles) 一节的罗列）。

![](https://images.xiaozhuanlan.com/photo/2021/0e859cb5110c34d07e8645b45735c226.png)

**3.动态获取 content uri**，这个通过 `FileProvider.getUriForFile()` 即可将 file Uri 转换为传输时所需的 content Uri。

得到的结果比如：

```
content:
```

前面 `com.kunminx.fileprovider` 对应的是 manifest 中定义的 authorities，中间 `external_files/kunminx/photo` 分别是 file\_path 中定义的 name 和 path，最后就是文件名本身。

**最后是对传输文件方法的适配：**

![](https://images.xiaozhuanlan.com/photo/2021/0528d8b5e7933e263dc4a5caff4edde6.png)

> 这样梳理了一遍，关于 “**为什么适配 FileProvider**”、以及 “**FileProvider 适配为什么要做这些工作**”，是不是也都容易理解了呢？

### 分区存储 的存在缘由和适配

#### 分区存储 适配前的混沌世界

分区存储并不是什么新鲜的设计，而是 “本应如此” 的设计。

在谈论分区存储之前，我们先来回溯一下，上文提及的关于 存储访问的两大类作用：为了 “**效率和平衡**”、“**复用和隐私**” 而存在，因而存储访问从一开始就被设计为，包含 **私有目录和公有目录**。

私有目录 是专用于存放 App 私有的 **缓存、配置、私密信息** 等等；

公有目录 是用于存放那些可复用的媒体文件，例如 **图片表情** 等等。

> 出于节省存储空间的考虑，**当 App 被卸载时，私有目录也随即被清空**，以便自动将缓存清理。因而 那些需要复用的文件 可存放在公有目录。
> 
> 划重点 👆 👆 👆

并且考虑到缓存大文件的需要，因而 **私有目录在 “内部空间 和 外部空间” 各有分布**，而大文件缓存就主要存储在 空间相对充裕的外部空间：

![](https://images.xiaozhuanlan.com/photo/2021/56d492ab5095eca14fad3bb58a1de4c0.png)

> **Tip：外部空间 除了私有目录外的区域 都是公有目录**

这种 “公私分明” 的设计还有什么好处呢？有的，

例如用户打开相册时，通常能 **瞬间载入**、并且只呈现公有目录下 **用户主动保存的图片**，而更少地会将缓存图片也展示出来，之所以可以做到这一点，是因为 相册中的记录都是 **源于 MediaStore（媒体库）的相关组件 事先对公有目录的扫描**，并且扫描过程中会主动跳过私有目录。

> 划重点 👆 👆 👆

但是，总是会存在一些 App 开发者，对私有目录毫无概念，随意在公有目录保存缓存的图片，使你打开相册 映入眼帘的就是些 “不知道什么时候被下载下来的” 乱七八糟的图片。

![如图，缓存广告图片被显示在相册中](https://images.xiaozhuanlan.com/photo/2021/6fe94ad2f835a1799bdb25ab90c2e477.png)

如图，缓存广告图片被显示在相册中

> **分区存储应运而生**

#### 分区存储 是如何解决这个问题的

在分区存储的强制规范下，媒体文件要存放到公有目录，就必须直接或间接地使用 MediaStore 的 API 来手动 “**备案**” 到媒体库，这样要求带来什么好处呢？

> 首先，它**强制要求备案时填写 “相对路径”**（见下文 MediaStore 的代码），**且相对路径的根节点 务必是 “公有目录默认媒体目录分类” 的其中一个**，例如 “Picture、DCIM、Music、Video、Document、Download” 等等，
> 
> 其次，**在 Android 11 及以后的系统中，就算申请了外部空间读写权限，直接通过 File Uri 来读写也会抛出异常**。

为什么要这样设计呢？为的是阻止那些 “不遵守规则的开发者” 透过 File Uri 在外部空间随处新建文件夹，而**只能基于 content Uri 在指定目录的 “虚拟目录映射” 下创建子目录和读写媒体内容**，

因而这些开发者等于是 **被迫遵循了规范**：要么是老老实实地在私有目录下存储缓存，要么是万不得已需要存储可复用媒体文件时，才大费周折地在默认媒体目录下建一个自己 App 的子目录来存储，而不至于眼花缭乱弄的满地都是。

![如图，Android 9 外部空间被随处新建的各种缓存文件夹](https://images.xiaozhuanlan.com/photo/2021/f476e5104c681cf947ab35c573c3fc7e.png)

如图，Android 9 外部空间被随处新建的各种缓存文件夹

归根结底，**分区存储的重要目标之一就是 “还用户一个干净的公有目录”**。

> 划重点 👆 👆 👆

具体而言：

1.访问本 App “外部空间的私有目录” 时，可直接透过上文罗列的 `Context.getExternalFilesDirs()` 等方法进行访问，无需申请运行时权限

> 这个设定其实一直以来都成立，只不过多数人完全不知情，一来他们 **从未反思过 也不清楚 “外部空间私有目录” 的存在**，二来他们只知道 “只要是外部空间就去使用 `Environment.getExternalStorageDirectory()`，而该方法的使用就不得不在 manifest 中配置 **外置存储访问的读写权限**”。
> 
> 划重点 👆 👆 👆 👆 👆

2.访问本 App “外部空间的公有媒体文件” 时，可透过 MediaStore 来访问，且 **同样无需申请访问权限**。唯有透过 MediaStore 访问其他 App 的 “外部空间的公有媒体文件” 时，需要申请权限。（该设定适用于 Android 10 及后来的系统。）

> 划重点 👆 👆 👆
> 
> 从 Android 10 起，MediaStore 有 2 个坑需要注意，详见文末 Note 2020.12.21 加餐。

![](https://images.xiaozhuanlan.com/photo/2021/57aa2bfbe17f924bcc26059841bb0f6d.png)

3.通过 SAF（全称 Storage Access Framework，存储访问框架）**无需权限即可访问自己或其他 App 的公有媒体文件**（SAF 是 Android 4.4 就存在的设计，只不过，SAF 的用户体验一言难尽，例如一次只能选一张图片、每次都是从根目录访问、Android 11 SAF 让人摸不着头脑的交互等等 … ）

![SAF](https://images.xiaozhuanlan.com/photo/2021/60dd234dfa374e7d144e0590f64a0d70.png)

SAF

![](https://images.xiaozhuanlan.com/photo/2021/ac8b6c5aaacff58a16d9e5711902343c.png)

简言之，在 Android 11 下：

![](https://images.xiaozhuanlan.com/photo/2021/d7d9a9a1a0af5daf7e57ec857abd8e41.png)

> 这样梳理了一遍，关于 “**为什么适配分区存储**”、“**分区存储的适配为什么要做这些工作**”、“**具体都有哪些场景、且各场景下有哪些方式可应对**”，是不是也都容易理解了呢？

### 综上

“存储访问” 主要是从 “**效率和复用**” 的角度出发，透过 **缓存** 来提升访问效率、降低服务器负担，透过 持久化存储 来实现媒体数据的复用。

> 在所有的 “数据交互” 活动中，存储访问是极其高频的存在，任何 “移动互联网客户端” 的操作都离不开它，是起到 **承上启下** 的作用。

“存储访问适配” 主要是从 “**保护用户隐私**” 的角度出发，透过新的传输机制，来确保本 App 的私密空间信息不被越界访问和泄漏。

> 存储访问体系在历史上曾有过多次局部的更新，我们 **所谓的适配，多是去适配这些 “从隐私安全角度出发” 的局部新设计**。

当我们在说适配的时候，我们实际是在兼容旧系统设计的同时，在新系统下遵循新设计。

当我们在适配 FileProvider 时，我们实际上是透过 **App 指定目录的 “虚拟目录映射” + 时机可控 且作用域有限的 “运行时权限”**，来替代 7.0 之前系统采用的 “底层文件系统读写权限无差别开放” 的不安全设计。

当我们在适配 分区存储时，我们实际上是被迫遵循强制规范：通过被迫只在 **系统指定的默认媒体根目录的 “虚拟目录映射”** 下创建子目录，来还用户一个清朗的外部存储空间。

这样说，你理解了吗？

### Note 2020.12.21 加餐：

#### 从 Android 10 起，MediaStore 有 2 个坑需要注意

1.从 Android 10 起，MediaStore 方式访问自己 App 公有数据时，支持全类型的数据；

而当访问别的 App 的公有数据时，MediaStore 方式仅可通过 Images、Audio、Video 这三种 Uri（例如 `MediaStore.Images.Media.EXTERNAL_CONTENT_URI`）访问媒体文件，Downloads 目录下的文档（例如 \*.txt 等）则是只可通过 SAF 读写。

2.从 Android 10 起，MediaStore 在插入新的媒体记录时，会自动添加当前 App 包名到 `MediaStore.Files.FileColumns.OWNER_PACKAGE_NAME` 字段，并且后续访问时，也是根据该字段的值，来判断数据是否属于当前 App（从而决定是否需要权限才可访问）。

而当自己 App 卸载后，自己 App 的公有数据将失去 `OWNER_PACKAGE_NAME` 的值，从而沦为 “无主的数据”，此时通过 MediaStore 方式访问，就像 “访问其他 App 的数据” 一样需要申请权限。

对此姑且认为是个 “反人类” 的设计，因为符合用户预期的做法时，App 卸载并重装后，之前创建的公共数据 “还在”。

### Note 2020.12.27 加餐：

#### 适用于团队开发的、记忆成本较低的 “分区存储” 统一适配参考建议

现实中，我们往往是以 “多人协作的团队开发” 为背景开展工作的，每个人都有各自专注的领域，乃至难以确保 每个成员都对各个细节的认知做到面面俱到，

因而有必要探索一种在 **学习成本、记忆成本、研发成本** 上取得平衡的适配方案。

所以这里分享一则较小适配成本的参考建议：

1.结合上文的分析，我们已知，在访问 “本 App 在内外空间的私有目录” 时，可通过 Context 方式无需权限地访问，这个操作从 Android 4.4 起往后都是一致的。

2.对于外部空间的公有目录的读写，从 Android 4.4 起到往后都可通过 SAF 来完成，无需申请权限。

SAF 的缺点是 界面单调、操作不便、不可定制交互，因而如果 App 十分重视统一的 UI 风格，那么从 Android 4.4 到 Android 10，我们可以统一通过 `Environment.getExternalStorageDirectory()` 以 File Api 的方式读写（需要申请权限），而只有 Android 11 起才使用 MediaStore 等方式。

注意此时 Android 10 须通过在 manifest 的 Application 节点添加 `requestLegacyExternalStorage = true` 来声明对 File Api 方式的兼容。

简言之就是：

![](https://images.xiaozhuanlan.com/photo/2021/16b6d1e31f91308951a2122ccd885816.png)

> **快捷访问：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)

### 版权声明

> Copyright © 2019-present KunMinX

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。