---
created: 2021-10-13
source: https://xiaozhuanlan.com/topic/0162375948
author: 
---

# [重学安卓：不如我们 从零开始设计一套 视图系统 － 小专栏](https://xiaozhuanlan.com/topic/0162375948)


> [往期回顾](https://kunminx.gitbook.io/relearn-android/new_moments/zhong-xue-an-zhuo-liang-zhou-nian-hui-gu-yu-zhan-wang)，**[专栏目录](https://kunminx.gitbook.io/relearn-android/category)**，**[更新动态](https://kunminx.gitbook.io/relearn-android/new_moments)**，[优惠政策](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#you-hui-zheng-ce)，[版权须知](https://kunminx.gitbook.io/relearn-android/ban-quan-sheng-ming#ban-quan-xu-zhi)
> 
> 温馨提示：如果这是第一次接触《重学安卓》，可通过上述链接来访问和快速了解《重学安卓》专栏、获取它的目录、试读内容，以及了解它的最新动态 和 发展状况。
> 
> 截至目前，专栏已对 **体系化文章** 做了 1970 余次修订，数十位群友告诉我 受专栏的启发 他们也开启了写作之路。群里不定期会有小伙伴讨论适配问题、分享原创的开源库 和 提供内推机会，订阅后可随时进群交流。

## 前言

很高兴见到你！

上一期，我们以 冲出技术舒适圈 的方式，站在 用户体验交互设计 的视角，来从 根源的根源 将 滑动冲突的由来和普适解决方案 给过了一遍，相信阅读过这篇文章的小伙伴，对 滑动冲突 的印象已跑赢全网 99.9% 的 Android 开发者。

与此同时，在上周开源的 Jetpack MVVM 最佳实践中，我在详情页中应用了[《滑动冲突》](https://xiaozhuanlan.com/topic/8796215034)一篇所介绍的详情页连贯滑动的用户体验设计。

尽管许多用户因此而惊叹，“怎么会这么流畅”，我个人还是觉得不够满意：当我单手操作时，在作为曲面屏的 Galaxy S8 Plus 上，很难够得到屏幕左边缘 乃至呼出抽屉，这体验 “太难了”。

无动于衷

有动于衷

![](https://images.xiaozhuanlan.com/photo/2019/290313b8459f2f4baead18f2acee694a.gif)

![](https://images.xiaozhuanlan.com/photo/2019/d9082268091ed84406b86e25f097e1c3.gif)

于是，通过对这么一个微小的、容易让人熟视无睹的现象的观测，我们确立了这么一条普适的观点：

在用户单手握持且 贪婪地、懒洋洋地 浏览时，用户希望的是，**用尽可能小的 大拇指的划动幅度**，来实现本不大可能、但心中预期的结果 和 **大动作**。

那么，像图 2 那样 符合用户直觉 和 心理预期 的体验，从技术角度来讲，为什么能实现呢？或者换一种方式提问：到底是怎样的视图系统，使得我们有机会实现 这样的用户体验呢？

下面我们就带着这个问题，来从 根源的根源 开始探寻，为什么会有我们现在这样的视图系统、这个系统中包含的重要成分都有哪些、以及在这样的视图系统下，我们可以通过何种方式 来实现上述我们所预期的效果。

## 文章目录一览

-   前言
-   作为 13 年前才面市的新型用户体验
    -   First of all
    -   Secondly
    -   And then
    -   However
-   So
    -   **视图系统的坐标系 为何如此设计？**
    -   视图坐标 为何如此设计？
    -   为什么能做到 惯性滑动？
    -   **惯性滑动的测量值 为何如此设计？**
    -   为什么能做到 位移？
    -   **事件分发 为何要如此设计？**
-   综上

## 作为 13 年前才面市的新型用户体验

世界上的第一台 **全触屏智能手机**，是 2007 年苹果发布的 iPhone。在那之前，人类社会根本没有这样的移动设备。

换言之，第一个设计并使之面市的创造者，**重新定义** 并引领了 后来的十几年里 人们对移动设备的 **用户体验习惯**：

在上一篇中我们介绍过，由于人们使用 智能手机 的动机 多是 打发无聊 或 查阅信息，因而 **最普遍的操作意图就是浏览**，而最普遍的操作方式之一 就是 **单手握持 并通过大拇指 划动屏幕**。

![](https://images.xiaozhuanlan.com/photo/2019/36884711aecba8bfad875f9cdb40a306.jpg)

当然，创造者们 早人们一步 想象到未来的这个情况。

所以不妨继续发挥我们的想象力，想象一下，当时的创造者们，对这样一种 全触屏设备 有着怎样的规划、以及为了实现这些规划，需要存在哪些 最少必要的成分 呢？

## First of all

我们需要确保，这台 全触屏设备，是个如假包换的 **冯诺依曼计算机**。无论是在 2007 年的当时 移动蜂窝数据网络处于 2G 的情况，还是未来 5 年内处于 5G 的情况。

因为就算是云手机，作为全触屏移动设备 也需要 能在本地 独立处理一些 最少必要的计算 —— 世界上绝不会存在 完全不具备算力的 智能手机。

（云计算并不代表 将 计算的任务 全部外包给云端，而是 将 **特定的计算任务** 外包给云端。**移动设备 必然需要 本地算力**，以便至少能够支撑 操作系统对硬件资源的调度 和对上层软件的支持）

![](https://images.xiaozhuanlan.com/photo/2019/c183ca8130bf3ab79c834a512f2290a9.png)

![](https://images.xiaozhuanlan.com/photo/2019/4b9697c11c25ecec4d240e45c6aedd21.png)

![](https://images.xiaozhuanlan.com/photo/2019/3ab3e4dfb9613277450de611582e6bbc.png)

![](https://images.xiaozhuanlan.com/photo/2019/da10bfb6d5d562a32ed679ba68a5b01f.png)

> 图片来自《钢铁苍穹》—— 1945 年的社会人 对 2012 年的社会人的 计算机 的评价。

此外，正因为是 冯诺依曼计算机，所以这台独立的 全触屏设备，**务必包含 输入设备 和 输出设备**。

输出设备 很好理解，例如 屏幕、外放 等等，当然我们今天谈的是 视图系统，所以这里我们只关注 屏幕。

与此同时，与传统台式机不同的是，**全触屏设备的 输入设备 也是屏幕**，用户 对可视化元素 **发起指令**，就是靠这块屏幕。

至此，我们可以做个小结：

> 1.我们构想的 全触屏移动设备，务必是一台 具备独立算力的 冯诺依曼计算机。
> 
> 2.从而它的背景状况是，通过 屏幕来负责 可视化元素的展示，和 接收用户通过屏幕发起的指令。

而光是确立了这两点，就不难望见 全触屏设备 **操控可视化元素 的整个逻辑** —— 分两步：

一步是 **接收指令**，

另一步是 **基于指令 实时地 重新渲染屏幕内容**。

于是，我迫不及待地要进入下一环节，来使这个逻辑完整落地。

## Secondly

通过上一小节的追溯和分析，我们知道了 所处的背景环境是，全触屏可移动设备 务必是一台 冯诺依曼计算机、而全触屏 同时兼任 输入设备和输出设备 两大职能，

因而，为了 **在这样的背景下**，完成 符合用户直觉的、所见即所得 的 操控体验，我们的视图系统 会分别准备两套组件，来基于这两种设备的表现 对用户体验负责，

其中，**触摸事件组件 对应的是 输入设备**，而 **排版渲染组件 对应的是 输出设备**。

于是，对输入设备来说，我们需要一个或多个坐标系，来为我们的触控操作 提供 实时坐标反馈，从而能够 **基于实时坐标 和 某些预设好的指标 来辨别我们在触屏上的操作，以便输送 正确的、符合预期的指令**，去通知 排版渲染组件 完成相应的工作。

同时，对于输出设备来说，我们同样需要一个或多个坐标系，来 **根据 触控指令或布局 实时排版和渲染 可视化元素**。

![](https://images.xiaozhuanlan.com/photo/2019/4453d4ce4b8dd77a47af36632bd3b13a.gif)

换言之，如果一个 可视化元素跟随你的手指移动了，这个过程必然是分两步走的：先是根据触控获取了坐标轨迹和指令，然后是根据坐标、指令、横纵差等计算出加速度等数值，并根据这些数值 通过某些组件，来实现 元素内容的惯性滑动，或元素本身的位移。

而之所以分两步走 却能符合用户直觉，又是因为这些触控信号被设计为 “实时发送”，例如每隔 16ms 截取一次（当前的坐标），也即 **每一段从直觉上 看似轻松连贯的 划动操作**，实际都包含无数次 “输入指令” 和 “输出渲染” 的交替执行。

那么至此，我们可以做个小结：

> 1.为了在以 **冯诺依曼计算机 为背景** 的条件下 实现 符合用户直觉的 所见即所得 操作，我们需要分别为 输入设备和输出设备 准备 **触摸事件组件 和 排版渲染组件**，分别用于 **实时输送指令 和 实时展示结果**。
> 
> 2.触摸事件组件 和 排版渲染组件 分别需要一个或多个坐标系，来为触控和排版提供坐标依据，以及基于 坐标轨迹 和 预设的指标 来辨别输入的指令，以期 通知对应的渲染工作的执行。

在确立了这两点后，我们终于可以开始 对视图系统做一个 具体的构思！

## And then

作为创造者们，我们首先从 输入系统开始构思。

—— 请对着手中 四角圆润、黑乎乎的 “板砖” 发呆一下：通常我们的触控操作 都会有哪些呢？

> 1.点击（Click），点击按钮，即按下（Down）、松开（Up），
> 
> 2.划动（Fling），划动内容，即按下（Down）、移动（Move）、松开（Up），并且让内容 保持惯性 滑动一小段距离。
> 
> 3.拖拽（Drag），拖拽元素，即按下（Down）、移动（Move）、松开（Up）。

由此可见，划动和拖拽在使用过程中，需要一些指标来做出区分：

> **对于内容要能惯性滑动，而对于元素要能拖拽** —— 要是反其道而行的话：
> 
> 内容划动松开后 立刻停止滑动，就会与直觉不符、令人感到十分突然；
> 
> 而元素拖拽松开后 还在漂移，就会与预期不符、令人感到十分不安。

而假如所处场景既是（列表）内容，又要能拖拽（列表）item 的话，就需进一步提供一些指标来区分，例如 长按（LongClick）或其他方式，让场景默认处于划动模式、而被动处于拖拽模式。

至此，我们可以做个小结：

> 1.常见的触控操作包括 **点击、划动、拖拽**，而它们又可被分解为 按下、移动、松开 等 **原子操作**。
> 
> 2.在不同的场景下 需要恰当地处理好 后续的滑动渲染，以免造成 不符合直觉的 用户体验。

于是，从每一次的 完整的触控过程中，我们可以最终得到一条坐标轨迹、在期间被识别和定性的原子操作（ Down、Move or Up），以及基于原子操作而被定性的宏观操作（Click、Fling or Drag），而这些宏观操作、原子操作 以及 坐标轨迹，都会被反馈到 排版渲染组件，从而 排版渲染组件：

> 1.根据坐标差，来判断出滑动的方向，
> 
> 2.根据坐标差，结合系统预设的坐标截取周期（例如 16ms），来判断滑动的加速度，
> 
> 3.根据被辨别的宏观操作模式，来决定是继续惯性滑动，还是戛然而止。

从而，人们所期待的 触控事件组件 的 **背景基石，就此落地**。

然而，触控事件 并不是 输入设备 “一个人的自嗨”，它的存在也要兼顾 排版渲染系统。  
因而，在 排版渲染系统的背景下，也就有了 Android 的事件分发系统。具体是这样的：

## However

为了塑造符合用户直觉的、所见即所得的 用户体验，视图排版的方式被设计为，父容器 嵌套 子控件，且越是作为子的控件，就越是置于前景、能被人们第一个所接触。

所以，**考虑到这一点**，触控事件组件 的坐标系，**不仅包含 屏幕绝对坐标系，也包含 相对坐标系**。

相对坐标系的存在，主要是为了 **方便对 视图区域内 与触摸坐标相关的计算**。

例如当实现 **滑动拼图验证码** 的时候，使用相对坐标系获取 相对坐标差，要比使用 屏幕绝对坐标系获取 相对坐标差 来得 **更简便**，因为后者还需手动将 当前触控视图与存在于外部的其他间距 排除。

![](https://images.xiaozhuanlan.com/photo/2019/5e72c7dd66e0dc63002ac50942a01333.png)

> （注意 “相对坐标系” 和 “相对坐标差” 在概念上的区别，相对坐标系是指 坐标系本身是建立在随时可能发生位移的视图原点，而非方位绝不变化的屏幕原点）

那么，既然提到了 坐标和坐标系，我们该怎样设计 坐标系呢？

当时的设计者们，一定是直接照抄 PC 系统中的坐标系，因为这套坐标系 自可视化操作系统 被施乐发明以来，已经得到几十年的演化 并最终成熟定型了。

然而尽管如此，也不妨碍我们进一步去思考，可视化坐标系 为何要如此设计：

## So

## 视图系统的坐标系 为何如此设计？

无论 屏幕坐标系，还是 视图坐标系，一律是 **以左上角为原点，X 轴向右和 Y 轴向下 为正方向** 的坐标系。

为何如此设计呢？为什么不是 y 轴向上 为正方向呢？

因为屏幕的大小总是有限的，容器的内容总有一部分在屏幕之外。例如 列表的大部分内容 在进入视野之前，都在屏幕之外的下方之处。**如果我们以 y 轴向上为正轴，那么 内容的坐标 就不好定义了**，所以干脆将左上角作为原点，这样无论是 视图 还是 视图的内容 都是从零开始进入，比较好计算。

## 视图坐标 为何如此设计？

考虑到视图存在嵌套的情况，那么视图坐标一定是 相对坐标。

于是无论视图渲染的内容如何，视图在系统看来，都是一个有 4 个边的矩形，从而当我们定义了视图的 左、上、右、下 四个边的坐标，我们便定义了视图的 相对方位 和 形状大小。

![](https://images.xiaozhuanlan.com/photo/2019/bc017fe9da2f70648042ead819358813.png)

并且，正由于视图坐标是相对的，因而 **为了简便，我们将 左右、上下 的坐标分别设计为 相对于父容器 的左边缘 和 上边缘，也即相对于 父容器的原点坐标 来标注**。

与此同时，在拿到了 左右上下的坐标，我们通过相对坐标之差，可以算出视图的宽高。

## 为什么能做到 惯性滑动？

先前我们提到过，是 **先有 触控事件系统 下的 划动操作，再有 排版渲染系统 下的 内容惯性滑动**。

也即这边我们要严格区分 划动（Fling） 和 惯性滑动（Scroll）：

> 一个是主动，一个是被动；
> 
> 一个是输入，一个是输出，要明确区分这一点。

所以这里提到的 滑动，就是 **被动的 惯性滑动**。

那么为了做到惯性滑动，我们需要根据在《And then》一节提到的 **坐标差、方向、加速度** 等数据，来 **计算、控制和不断渲染 内容朝某方向的惯性滑动**。

> 在 Android 中，惯性滑动 最终是通过 Scroller 来实现。
> 
> 当然，为了 **在软件工程的背景下** 不易出错，SDK 已为我们封装好了 **开箱即用的** scrollTo 和 scrollBy。

以上是关于 惯性滑动 的基本原理。具体的源码解析，网上一抓一大把，这里就不做累述了。

对于惯性滑动在 Android 平台上的源码实现，我为你找到了这一篇：

[https://github.com/Idtk/Blog/blob/master/Blog/8%E3%80%81Scroll.md](https://github.com/Idtk/Blog/blob/master/Blog/8%E3%80%81Scroll.md)

如果你对 iOS、Flutter 比较熟悉，不妨在评论区贴几篇 你自己看的好的源码实现文章，大家一起对照着看看，各平台的具体实现 是否大同小异。

## 惯性滑动的测量值 为何如此设计？

多数文章会提到：

> 当内容的左边缘 在 视图左边缘的左边时，mScrollX 为正值，反之为负值；
> 
> 当内容的上边缘 在 视图上边缘的上边时，mScrollY 为正值，反之为负值。

你知道为什么这么设计吗？

其实很好理解，看图：

![](https://images.xiaozhuanlan.com/photo/2019/70ba5c2c01213cc89313896694baf524.gif)

> 联系到日常生活中，将内容比作 **自身带有刻度的**、不断在相框中移动的胶片，就很容易理解为何存在这样的设计。—— ©KunMinX

具体而言，

首先，scrollTo 和 scrollBy **改变的是 视图 内容 的方位**，而不是 视图 本身在布局中的方位。也即此时 **一直在位移的 是内容本身**、所获取到的测量值 也一定是来自内容。

其次，内容的原点 正常来说是与 视图的左边缘（当横向滚动）或上边缘（当纵向滚动）重叠，

因而设计为，取 **与视图 左边缘或上边缘 相交的 内容坐标值**，也即 **相交量**，来作为 内容横向或纵向滑动时的 **方位的指标**。

与此同时，内容本身坐标的取值，符合坐标系的设计。越往右、越往下的内容，坐标测量值越大。

## 为什么能做到 位移？

前面我们提到过，视图内容是惯性滑动，视图本身则是非惯性滑动，也即 **在 拖拽（Drag）的带动下，发生的 被动的位移（Transition）**。

所以实现视图的位移，其实很简单，通常有两种办法：

> 1.通过 属性动画 去实现视图的位移，
> 
> 2.通过 改变布局参数 来实现位移。

第一种方式在实现上符合直觉，因为 **动画的本质 就是让事物状态的变化 有个可观测的、渐变的过程**。

其中，`x = left + translationX`，`y = top + translationY`，你知道为什么这么设计吗？

视图的 x、y 和 translationX、translationY 属性，都是 Android 3.0 时随着 属性动画的引入而引入的，它们的存在，就是在确保 `left、top、right、bottom` 等原始坐标不变的情况下，通过设置 **偏移量** translation，来使视图最终的方位 x、y 发生变化，而视图系统就是以这个 x、y 为基准来渲染最终结果。

也即，当 x 在 left 左侧，transitionX 小于 0；当 y 在 top 底部，transitionY 大于 0。

> 这么做 在某种程度上符合 “开闭原则”：对修改关闭，对拓展开放。

第二种方式不符合直觉，但很直接：因为它的做法是 **在变化过程的每一帧中，都直接改变 整个布局的结果**，来成全视觉上的感觉 就只有这个 视图本身 在发生位移。

这种方式需要你自行定义 offset 变量、酌情累加到视图的 `left、top、right、bottom`。因而相比 纯粹的动画属性位移，第二种方式更适合 **视图在位移的过程中 发生形变** 的情况，因为 offset 变量可以定义多个、可以分别赋予和操控 最终的布局结果。

关于 Android 平台动画位移的具体源码实现，可参考这篇文章：

[https://juejin.im/post/59af4b415188252427260c3d#heading-2](https://juejin.im/post/59af4b415188252427260c3d#heading-2)

Android 平台通过 改变布局属性 来实现 视图位移效果，可参考这篇：

[https://blog.csdn.net/shakespeare001/article/details/51657795](https://blog.csdn.net/shakespeare001/article/details/51657795)

## 事件分发 为何要如此设计？

在《And then》一节，我们推知了 视图系统因 触摸事件组件 需要兼顾 排版渲染组件，而设计了事件分发系统。

并且在《However》一节，我们也交代了：正因为 符合直觉、所见即所得 的需要，使得我们将 排版渲染组件 设计为，嵌套越深的子控件，越是置于前景、为人们第一个所接触。

又因为，这是个可交互的开放系统，因而这里的接触不仅仅是指可以看见，同时也是指可以被触控，也即对指令发生响应。

于是，事件分发系统，便效仿了 排版系统，通过 “递归”，来实现 符合直觉的 触控反馈。

关于事件分发，具体的内幕 可参考 7 月份 我在掘金发表的 [《学习 View 事件分发，就像外地人上了黑车》](https://juejin.im/post/5d3140c951882565dd5a66ef)

那么到此为止，视图系统的触控知识，我们介绍得差不多了，相信经过这么一次 **体系化的、全局的 概览**，大家对 触控的本质 有了更加深入的理解，在遇到需要 定制手势 以塑造符合直觉的 用户体验时，也会更加 泰然自若、游刃有余。

## 综上

我们谈论的视图系统，是 **专指 在作为冯诺依曼计算机的 全触屏移动设备 这样背景下的** 视图系统。

因而为了实现 **符合直觉、所见即所得的 用户体验**，它务必 **兼顾 排版渲染 和 触控事件**。

为了做到这一点，视图系统需要有一套 **绝对的、统一的、通用的 坐标系**，来根据 **实时捕获到的坐标轨迹** 判断 当前的指令、方向、加速度等信息，从而去指导 排版渲染组件中 视图元素及其内容的 变化和响应。

并且，出于综合考虑（例如内容滚动时测量值的截取），坐标系一律是以 左上角为原点、X 轴向右、Y 轴向下为正方向。

同时，为了简化特定区域的计算和实现，除了 屏幕绝对坐标系，触控事件组件还提供了相对坐标系（例如用于 滑动拼图验证码的实现）。

此外，为了实现符合直觉的 滑动体验，排版渲染组件 在 视图内容滑动 和 视图本身滑动 这两种情景下，分别提供了 **带惯性效果的 Fling** 和 **不带惯性效果的 Drag**。

其中，

-   为了更好地确定内容方位，视图内容滑动时的 scroll 值，被设计为 取的是内容左边缘或上边缘 与视图原点的相交量。
-   为了更好地控制视图本身的位移，视图滑动时的 transition 值，被设计为 取的是视图最终与父容器的距离和视图原始坐标的偏离量。
-   为了实现 Fling 的惯性效果，Android 平台提供了基于 Scroller 开发的滑动计算套件。
-   为了实现实现 Drag，即视图的位移效果，Android 平台提供了 基于 属性动画 和 修改布局属性这两种方式。

再者，**为了实现 所见即所得的 触控效果，触控事件组件 以 事件分发的形式来完成指令的传导**，以期能够将指令送达到预期的视图元素身上，发生响应。

但由于 用户体验 和 技术实现 本身是两个独立的存在，因此 **当技术实现 缺乏临界点指标 去指导变化时，即造成了从 用户体验角度来讲的滑动冲突**。

对于视图内容及视图的滑动冲突的解决，在上一节我们已经介绍到。而经过这一节对 视图系统 来龙去脉 的体系化讲解，加上对[《事件分发》](https://juejin.im/post/5d3140c951882565dd5a66ef)一文的阅读，我相信大家对 滑动冲突的本质的理解 和 对滑动冲突通过原始的方式处理的灵感，已是呼之欲出。

最后，关于文章开头提到的对抽屉的 “无动于衷”，现在看来，有没有解法呢？

有的，其实很简单，首先，尽管呼出抽屉的场景是在 最近播放列表 RecyclerView —— 尽管它是个列表，但呼出操作的划动，本质上是对 视图的 Drag，而不是对 视图内容的 Fling，具体可在 [酷安](https://www.coolapk.com/apk/247826) 下载最佳实践 APK 来体验。

> **便捷链接：**
> 
> **[基本功：是随时随地可受用的 深度思考原则](https://xiaozhuanlan.com/topic/9837051426)**
> 
> [GitHub : 重学安卓 配套项目](https://github.com/KunMinX/Relearn-Android)
> 
> [GitHub : Jetpack-MVVM-Best-Practice](https://github.com/KunMinX/Jetpack-MVVM-Best-Practice)
> 
> **视图系列文章：**
> 
> [重学安卓：从 0 到 1 “自定义视图” 完整爬坑顺序](https://xiaozhuanlan.com/topic/9361075842)
> 
> [重学安卓：滑动冲突 的快乐你不懂！](https://xiaozhuanlan.com/topic/8796215034)
> 
> [重学安卓：不如我们 从零开始设计一套 视图系统](https://xiaozhuanlan.com/topic/0162375948)
> 
> [重学安卓：百闻不如一见的 视图系统 架构全貌](https://xiaozhuanlan.com/topic/6420935178)
> 
> **[重学安卓：过目难忘 Android GUI 关系梳理](https://xiaozhuanlan.com/topic/2073915486)**
> 
> [重学安卓：一通百通 “声明式 UI” 扫盲干货](https://xiaozhuanlan.com/topic/2356748910)

## 版权声明

> Copyright © 2019-present KunMinX

**本文为专栏私有内容，谢绝转载**。

读者订阅了专栏，即享有了专栏文章的阅读权。

文章 **原创的引言、切入点、思路、结论** 凝聚了作者 KunMinX 本人的心血 及与参与者互动演化的结果，作者本人及作者在文中提名的有效贡献者 对相应的成果享有所有权。

**当您 借鉴或引用文中的引言、切入点、思路、结论 进行二次创作并打算发行时，须注明链接出处**，否则我们保留追责的权利。对此如有疑虑请及时沟通，或在发行前将作品交由本人核对。

当您看见有人 [洗稿](https://baike.baidu.com/item/%E6%B4%97%E7%A8%BF/20862574?fr=aladdin)、[剽窃](https://baike.baidu.com/item/%E5%89%BD%E7%AA%83/9398357?fr=aladdin)、未经授权转载本专栏的文章内容时，请及时向本人举报。

最后感谢您对专栏内容的阅读和喜欢。
